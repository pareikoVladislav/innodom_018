# **Tuples**

**Кортеж** – это индексированная структура данных, похожая на список,\
предназначенная для безопасного извлечения и отправки данных, а также\
для безопасного их хранения

**Кортеж** – это неизменяемая коллекция, которая содержит ряд\
преимуществ:

* данные, хранящиеся в кортеже, невозможно изменить, они полностью\
защищены от “случайных” изменений;
* кортеж как структура занимает меньший вес в памяти;
* кортеж можно использовать ключом словаря.


Для создания кортежа используются **круглые скобки** либо функция\
`tuple()`             

Если заключить данные просто в круглые скобки, то кортеж не будет\
создан. Для того, чтобы создать кортеж с одним элементом, нужно\
поставить после него **запятую**. Например: `(1, )` - это **кортеж**.

```python
list_ = [1, 2, 3]

my_tuple = tuple(list_)

my_tuple_1 = (4, 5, 6)
```

На кортежи действуют все методы и функции списков, которые не\
изменяют данные внутри структуры.


# **Tuples methods**

* `count()` - подсчитывает количество вхождений опр. значения в кортеж
* `index()` - возвращает индекс первого вхождения элемента, который\
передаётся в метод

```python
my_tuple = ()
my_tuple_1 = tuple()
```

Где наши кортежи могут применяться?

* **Обработка данных** из базы данных: Кортежи могут быть использованы для\
представления результатов запросов к базе данных. Например, при\
извлечении данных из таблицы можно использовать кортежи для хранения\
значений каждой строки. Методы, такие как `count()` и `index()`, могут\
использоваться для анализа и обработки этих данных.

* **Возвращение** нескольких значений из функции: Функции в Python могут\
возвращать кортежи в качестве результата. Например, функция, которая\
вычисляет минимальное и максимальное значение в списке, может вернуть\
кортеж из двух значений. Затем можно использовать методы кортежей,\
такие как `count()` и `index()`, для работы с этими значениями.

* **Обмен значениями переменных**: Кортежи могут быть использованы для обмена\
значениями между переменными без необходимости использования\
временной переменной.

```python
a = 1
b = 2

print(f"До обмена: a = {a}, b = {b}")

a, b = b, a

print(f"После обмена: a = {a}, b = {b}")
```

* **Кеширование результатов**: Кортежи могут быть использованы в качестве\
ключей словаря для кеширования результатов вычислений. Например, если\
у вас есть функция с дорогостоящими вычислениями, вы можете сохранять\
результаты в словаре с ключами-кортежами аргументов функции. При\
повторных вызовах функции с теми же аргументами, вы можете использовать\
сохраненные значения вместо повторных вычислений.

* **Сопоставление именованных значений**: Кортежи могут использоваться для\
сопоставления именованных значений, когда требуется более сложная структура\
данных, чем просто набор переменных. Например, можно использовать кортежи для\
представления информации о студентах, где каждый кортеж содержит имя, возраст,\
оценки и другую информацию о студенте.


# **Set:**

**Множества** - неиндексированная структура данных, в которой элементы\
хранятся в случайном порядке и не могут повторятся. Если при создании\
множества элементы в нём повторяются, то повторные элементы из множества\
удаляются. Благодаря этим особенностям, операции с множествами выполняются\
значительно быстрее и с меньшей производительностью.


**Множества** могут быть **изменяемыми** (`set()`) и **неизменяемыми** (`frozenset()`)

Синтаксис создания множеств:

```python
my_set = set()
my_set_1 = {1, 4, 2}

my_frozenset = frozenset((1, 4, 6, 2, 4))
```

При создании множеств мы можем хранить в них ТОЛЬКО уникальные значения, неизменяемые

Любой изменяемый тип данных уникальным быть **не может**

Внутренняя реализация set базируется на **хэшировании** и **таблицах хэшей**\
(hash tables). Вот как это работает:

* Когда мы создаём пустой **set** с помощью **my_set = set()**, Python\
создает пустую **хэш-таблицу**.

* При добавлении элемента в **set**, Python вычисляет хэш этого элемента\
(с использованием метода **hash**) и определяет, в какой "корзине" хранить этот\
элемент в **хэш-таблице**. Если несколько элементов имеют одинаковый хэш, они хранятся\
в одной корзине и решаются коллизии.

* При поиске элемента в **set**, Python вычисляет хэш этого элемента и быстро определяет,\
в какой корзине искать. Затем происходит сравнение элемента с элементами в корзине,\
и если элемент найден, возвращается результат.

* При удалении элемента из **set**, Python снова вычисляет хэш элемента и находит корзину,\
в которой он находится. Затем элемент удаляется из корзины.

* Это позволяет **set** обеспечивать быстрое добавление, удаление и проверку на\
наличие элементов за счет хорошей амортизированной временной сложности.


**frozenset** - это неизменяемая версия **set**, что означает, что после создания\
вы не можете изменить его содержимое. Внутренняя реализация **frozenset** схожа\
с **set**, но с одним основным отличием:


* Поскольку **frozenset** является неизменяемым, он может использовать хэширование\
всех своих элементов при создании, и этот хэш сохраняется. Это делает **frozenset**\
хэшируемым и, следовательно, может быть использован в качестве ключа в словарях **dict**.

* Так как **frozenset** неизменяем, он не подвержен операциям добавления\
или удаления элементов, что делает его полезным в ситуациях, когда\
вам нужно иметь неизменяемый набор элементов.

---

Очень интересно, но ничего непонятно, думаю. Давайте разбираться!

# **Hashing:**
**Хэширование** - это процесс преобразования входных данных (например, строк,\
чисел, объектов) в **фиксированный размерный хэш-код (хэш)**. Целью хэширования\
является уникальное представление данных с фиксированным размером, что\
позволяет **быстро** выполнить операции **поиска**, **добавления** и **удаления**\
элементов в структуре данных, основанной на **хэш-таблице**.


# **Hash Table:**
**Хэш-таблица** - это структура данных, которая использует хэширование для\
**эффективного хранения** и **быстрого доступа** к данным. Основная идея заключается в\
том, что каждый элемент хранится в корзине (бакете) на основе его хэш-кода.


**Корзины** представляют собой массивы или списки, и элементы с одинаковым хэш-кодом\
помещаются в одну и ту же корзину. Затем для поиска, добавления или удаления\
элемента необходимо вычислить его **хэш-код**, найти соответствующую корзину\
и выполнить операцию в этой корзине.

**Преимущества** хэш-таблиц заключаются в том, что операции добавления, поиска и\
удаления могут быть выполнены за постоянное время в среднем случае (**O(1)**),\
если **хэш-функция** хорошо распределяет элементы по корзинам.


# **Collision:**
**Коллизия** происходит, когда два разных элемента имеют одинаковый хэш-код и,\
следовательно, должны быть помещены в одну и ту же корзину. Коллизии\
неизбежны, так как хэш-коды ограничены по размеру, а количество данных,\
которые нужно хранить, может быть гораздо больше.

---

Так как наши множества могут хранить в себе только **неизменяемые типы данных**,\
мы можем хранить в нашем изменяемом множестве **set()** неизменяемый\
**frozenset()**, но наоборот - нет:

Благодаря множествам, можно выполнять математические операции со структурами\
данных (**объединение**, **пересечение**, **вычитание** и др) быстро и просто.

---

![img_14.png](https://raw.githubusercontent.com/pareikoVladislav/innoDom012/main/img_14.png)

---

# **Operations between sets:**


**Объединение множеств (|):**

При объединении создаётся **ещё одно множество**, которое содержит все\
элементы, входящие в первоначальные два (без дубликатов).

```python
set_1 = {"hello", 3, 3, 1, 9, "vlad"}
set_2 = {9, 10, 22, 4, 5, 6, "andrey"}

print(set_1 | set_2)
```

**Пересечение множеств (&):**

При пересечении создаётся новое множество, содержащее все элементы,\
**общие для обоих** (без дубликатов).

```python
set_1 = {"hello", 2, 3, 4}
set_2 = {"hello", 3, 4, 5, 6}
print(set_1 & set_2)
```

**Вычитание множеств (-):**

При использовании разности создаётся новое множество, включающее элементы,\
которые есть в **левом** множестве, но не входят в **правое** множество.

```python
set_1 = {"hello", 2, 3, "qwerty", 4}
set_2 = {3, 4, 5, "hello", 6, 7}

print(set_2 - set_1)
```

**Симметричное вычитание множеств (^):**

Создаётся новый объект, включающий все элементы, за исключением тех,\
которые есть в обоих множествах.

```python
set_1 = {1, "Vadim", 3, 6, 4, 5}
set_2 = {3, 5, "hello", 6, 7, 8}

print(set_1 ^ set_2)
```

Другими словами Питон проходится по каждому элементу в каждом из множеств,\
И записывает в новое множество только те элементы, которые есть исключительно\
в этом множестве.

---

# **Set methods:**

У множеств достаточно много разных методов:

* `.isdisjoint(other)` - возвращает **True**, если множество и\
**other** **не имеют** общих значений

```python
set_1 = {1, 2, 3, 10, 4, 5}
set_2 = {5, 6, 7, 8, 9, 10}

print(set_1.isdisjoint(set_2))
```

* `.issubset(other)` - вернёт **True**, если множество является\
подмножеством для **other**

```python
set_1 = {10, "Vova"}
set_2 = {1, 2, 3, "a", "b", 7, 5, 9}

print(set_1.issubset(set_2))
```

* `issuperset(other)` - вернёт **True**, если множество является\
надмножеством для **other**

```python
set_1 = {"b", 7, 5}
set_2 = {1, 2, 3, "a", "b", 7, 5, 9}

print(set_1.issuperset(set_2))
```

* `union(other_1, other_2)` - объединяет несколько множеств. **Аналогично (|)**

```python
female_students = {"Anna", "Nicka", "Valeria", "Kristin", "Maria"}
male_students = {"David", "Mike", "Nicka", "Adrey", "John", "Kristin", "Sumit"}


hight_school_students = set.union(female_students, male_students)

print(hight_school_students)

# или же 
print(female_students.union(male_students))
```

* `intersection(other)` - вернёт пересечение множеств. **Аналогично (&)**

```python
set_1 = {"hello", 2, 3, 4}
set_2 = {"hello", 3, 4, 5, 6}
set_3 = set.intersection(set_1, set_2)
print(set_3)
```

* `difference(other)` - вернёт множетво с элементами, не принадлежащими\
ни одному из other. **Аналогично (-)**

```python
set_1 = {"hello", 2, 3, "qwerty", 4}
set_2 = {3, 4, 5, "hello", 6, 7}
print(set_1.difference(set_2))
```

* `copy()` - создаёт копию множества

```python
sentitive_data = {12312353, 3454542, 443234, 6897655, 23456, 987654}

copy_of_data = sentitive_data.copy()
print(copy_of_data)
print(copy_of_data is sentitive_data)
```

Приведённые выше методы **не работают** с **frozenset**, кортежами и списками.

Так же есть методы, которые не возвращают нам новое множество, как было выше,\
а **изменяют наш текущий set** ( так как наш **set** - **изменяемый тип данных** ):


* `add()` - добавляет новый элемент в множество

```python
set_1 = {1, 2, 3, 4}

set_1.add("l")

print(set_1)
```

* `remove()` - удаляет элемент из множества. **KeyError**, если элемента\
во множестве нет.

```python
set_1 = {5, 6, 7, 8, 9}

set_1.remove(7)

print(set_1)
```

* `discard()` - аналог метода **remove**, только если элемента не найдено - ничего.

```python
set_1.discard("vlad")
```

* `pop()` - удаляет и возвращает элемент из множества.

```python
set_1 = {"a", "b", 1, 2, frozenset((7, 8, 9))}

a = set_1.pop()

print(set_1)
print(a)
```
* `clear()` - очищает множество

```python
set_1.clear()

print(set_1)
```

---

1) Создайте два множества **set1** и **set2**. Если они имеют хотя бы один\
общий элемент, выведите сообщение "Есть общие элементы", иначе\
выведите "Нет общих элементов".                       

2) Создайте два множества **a** и **b**, содержащих несколько элементов.\
Если множество a является подмножеством множества b, выведите\
"a - подмножество b", иначе выведите "a не является подмножеством b".

3) Создайте множество **fruits** с несколькими названиями фруктов. Попросите\
пользователя ввести название фрукта и удалите его из множества.\
Если фрукт был успешно удален, выведите "Фрукт удален из\
множества", иначе "Фрукт не найден".

4) Создайте два множества odd_numbers и even_numbers, содержащих нечетные\
и четные числа от 1 до 10 соответственно. Попросите пользователя ввести\
число и выведите "Четное" или "Нечетное" в зависимости от того,\
в каком множестве оно находится.

5) Создайте два множества set_a и set_b, содержащих различные элементы.\
Если хотя бы один из них меньше трёх элементов(включительно), объедините\
их в одно множество и выведите его содержимое.


---

# **Dict**

**Словари** - это неупорядоченная структура данных, в которой у\
каждого элемента есть своя ассоциация (ключ). Данные представляются\
в виде элементов ключ:значение.

Ключи могут быть **ТОЛЬКО** неизменяемыми типами данных, значения могут\
быть любыми типами данных.

```python
# new_dict = {} # создаст пустой словарь.
my_list = [1, 2, 3, 4, 5, 6]
students = {
    "name": "Vlad",
    "surname": "Lebovski",
    "age": 25,
    "sex": "male",
    "education": "engineer",
    5: "test"
}
```

Мы можем обращаться к ключам наших словарей, получая по ним значения:

```python
students["name"]
```

Если мы попытаемся таким образом обратиться к ключу, которого нет - получим\
**KeyError**:

```python
# student["work"]
```
Для этого у нас есть метод `.get()`

**Мы так же можем создавать новые ключи и давать им значения:**

```python
student["work"] = "Amazon company" # создаст новый ключ work и даст ему значение Amazon company
```

```python
del student[5] # удалит наш ключ 5 и его значение
```

**Как ещё можно создавать словари?**

```python
dict_1 = dict(name="Vlad",
              age=32,
              sex="binary person",
              job="driver",
              asd="asdasd")

print(dict_1)
```
```python
dict_2 = dict([("pet", "dog"), ("name", "fluffy"), ("age", 3), ("hungry", False)])

print(dict_2)
```

```python
keys_list = ("name", "age", "job")
values_list = ["David", 45, "QA"]

dict_3 = dict(zip(keys_list, values_list))
```

```python
# задача с собеседования
my_new_dict = {
    1: "father",
    False: "mother",
    True: "son",
}
```

**Вложенные словари:**

Мы так же можем создавать **вложенные словари** для создания более\
сложных структур. Частенько можно встретить в **JSON** данных,\
которые **backend** подготавливает для **frontend**.

```python
employee = {
    "id": 1,
    "name": "Valeria",
    "surname": "Black",
    "age": 21,
    "education": "hight",
    "current work": {
        "id": 1,
        "position": "QA engineer",
        "work experience": "3 years",
        "work qualification": "QA"
    }
}
```

```python
employee_1 = {
    "id": 1,
    "name": "Valeria",
    "surname": "Black",
    "age": 21,
    "education": "hight",
    "work_experience": [
        {
            "id": 1,
            "position": "QA engineer",
            "work experience": "5 years",
            "work qualification": "junior"
        },
        {
            "id": 2,
            "position": "software developer",
            "work experience": "1.3 years",
            "work qualification": "middle"
        },
        {
            "id": 3,
            "position": "QA engineer",
            "work experience": "1 years",
            "work qualification": "senior"
        }
    ],
}
```

---

# **Dict methods**

* `keys()`: Метод **keys()** возвращает представление всех ключей в словаре.

```python
employee.keys()
```

* `values()` возвращает представление всех значений в словаре.

```python
employee.values()
```

* `items()` возвращает представление всех пар "ключ-значение" в\
словаре в виде кортежей.

```python
employee.items()
```

* `get()`: позволяет получить значение по ключу с возможностью\
указать значение по умолчанию, если ключ не существует.

```python
employee.get("rabota", "NOT FOUND")
```

* `setdefault()`: позволяет получить значение по ключу, а если ключ\
не существует, то установить значение по умолчанию и вернуть его.

```python
employee.setdefault("pet", True)
```

* `fromkeys(iterable, value=None)`: оздает новый словарь, используя\
элементы из итерируемого объекта (например, список) как ключи, и\
устанавливает для каждого ключа значение по умолчанию (по\
умолчанию None, но вы можете указать своё значение).

```python
keys = ['a', 'b', 'c']
default_value = 0
new_dict = dict.fromkeys(keys, default_value)

print(new_dict)  # Вывод: {'a': 0, 'b': 0, 'c': 0}
```

* `pop(key, default)`: удаляет элемент из словаря по указанному\
ключу и возвращает его значение. Если ключ не найден, метод вернет\
значение, указанное в `default` (по умолчанию вызовет исключение\
`KeyError`).\

```python
my_dict = {'a': 1, 'b': 2, 'c': 3}
value = my_dict.pop('b')  # Удаляем ключ 'b' и получаем его значение

print(my_dict)  # Вывод: {'a': 1, 'c': 3}
print(value)    # Вывод: 2
```

* `popitem()`: удаляет и возвращает произвольный элемент (ключ-значение)\
из словаря. Этот метод может быть полезен, если вам не важно,\
какой именно элемент будет удален.

```python
my_dict = {'a': 1, 'b': 2, 'c': 3}
item = my_dict.popitem()  # Удаляем произвольный элемент

print(my_dict)  # Вывод: {'a': 1, 'b': 2}
print(item)     # Вывод: ('c', 3)
```

* `copy()`: создает и возвращает копию словаря. Эта копия будет\
независимой от исходного словаря, что означает, что изменения в\
копии не будут влиять на исходный словарь, и наоборот.

```python
original_dict = {'a': 1, 'b': 2, 'c': 3}
copied_dict = original_dict.copy()

copied_dict['a'] = 99  # Изменение копии не влияет на исходный словарь
print(original_dict)    # Вывод: {'a': 1, 'b': 2, 'c': 3}
print(copied_dict)      # Вывод: {'a': 99, 'b': 2, 'c': 3}
```

Обязательно помните, что если вам нужна копия вашего словаря, с какой-то\
вложенностью, и вы собираетесь как-то эту копию изменять - обычный метот\
`copy()` не сработает, так как для всех изменяемых объектов он оставляет\
прежние ссылки, тем самым при изменении вложенных структур в вашей копии\
вы будите изменять и вложенные структуры оригинала.

```python
a = {
    "b": [2, 4, 6, 8, 10],
    "c": 700,
    "d": {
        "a": 85
    }
}

f = a.copy()

f["b"][0] = 100
f["d"]["a"] = "700"

print(f)
print(a)
```

Чтобы такого поведения не происходило, подключайте в работу специальный\
метод `deepcopy()` из библиатеки `copy`

`deepcopy` - это функция из модуля copy в **Python**, которая используется для\
создания глубокой копии объекта. Глубокая копия означает, что все объекты\
внутри исходного объекта также копируются рекурсивно, то есть создаются\
копии всех вложенных объектов. Это полезно, когда вам нужно создать\
независимую копию сложной структуры данных, такой как вложенный словарь\
или список, чтобы изменения в одной копии не влияли на другую.


```python
import copy

a = {
    "b": [2, 4, 6, 8, 10],
    "c": 700,
    "d": {
        "a": 85
    }
}

f = copy.deepcopy(a)

f["b"][0] = 100
f["d"]["a"] = "700"

print(f)
print(a)
```

---

# **Conclusion:**

# **Common points for dict and set:**

* **Общие черты словарей и множеств:**
    * **Оба являются коллекциями в Python.**
    * **Позволяют хранить и организовывать данные.**
* **Основные различия между словарями и множествами:**
    * Словари хранят пары "ключ-значение", в то время как множества\
    хранят только уникальные элементы без порядка.
    * Доступ к значениям в словаре осуществляется по ключу, в\
    множестве - по самому элементу.
    * Словари могут содержать разные типы данных в качестве ключей и\
    значений, в то время как множества могут содержать только хешируемые\
    объекты(неизменяемые типы данных).
    * Множества поддерживают операции над множествами, такие как объединение,\
    пересечение и разность, в то время как словари таких операций не поддерживают


# **When dicts? When sets?**

* **Словари:**
    * Необходимо хранить и получать значения по уникальным ключам.
    * Нужно отображение между ключами и значениями.
    * Требуется изменяемость значений

* **Множества:**
    * Необходимо хранить только уникальные элементы без порядка.
    * Требуется выполнение операций над множествами, таких как объединение,\
    пересечение или разность.
    * Нужно проверить принадлежность элемента к множеству.


---

# **Homework**

1) Создайте словарь **student_grades**, где ключами будут имена студентов,\
а значениями - их оценки (целые числа). Запросите у пользователя имя\
студента и выведите его оценку. Если студент не найден в словаре,\
выведите "Студент не найден".

2) Создайте словарь **inventory** с товарами и их количеством в магазине.\
Попросите пользователя ввести название товара и проверьте, есть ли этот\
товар в словаре. Если товар не найден, установите для этого товара значение\
4 по умолчанию.

3) Создайте два словаря **english_words** и **spanish_words** с переводами английских\
и испанских слов. Попросите пользователя ввести слово на английском и\
выведите его перевод на испанский. Если слово не найдено, выведите\
"Перевод не найден".

```python
spanish_words = {
    "Бабочка": "Mariposa",
    "Обучение": "Formación",
    "Ресторан": "Restaurante",
    "Программирование": "Programación",
}

english_words = {
    "Butterfly": "Бабочка",
    "Training": "Обучение",
    "Restaurant": "Ресторан",
    "Programming": "Программирование",
}
```

4) Создайте словарь **phone_book** с именами контактов и их номерами телефонов.\
Попросите пользователя ввести имя контакта и выведите его номер.\
Если контакт не найден, спросите пользователя, хочет ли он создать новый контакт.\
Если да - создайте новый ключ с номером телефона, который пользователь должен\
будет ввести. Если нет - прекратить работу.

```python
book_contact = {
    "Andrey": "+1234568789",
    "Irina": "+793545613254",
    "Nikita": "+995557003215",
    "Alex": "789456123121",
}
```
