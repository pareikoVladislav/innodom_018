# **Files**                                                           

**Файлы** - это наборы данных, хранящиеся на компьютере или других устройствах.\
В программировании файлы играют важную роль, поскольку они позволяют\
программам взаимодействовать с внешним окружением, сохранять и получать\
данные, а также обмениваться информацией между различными программами.

**Файлы** представляют собой упорядоченные наборы данных, которые могут содержать текст,\
изображения, видео, аудио или другие форматы данных. Они могут быть сохранены на\
жестком диске компьютера, съемных носителях (например, USB-флешках) или\
доступны через сеть (через интернет).


Роль файлов в хранении данных заключается в том, что они позволяют программам\
сохранять и извлекать информацию для дальнейшего использования. Например, файлы\
могут содержать данные о настройках программы, результаты вычислений, текстовые\
документы, базы данных и ещё до кучи чего другого.

**Наши с вами файлы могут делиться на две категории:**

1) **Текстовые** - хранят символы и данные в том виде, в котором их\
внёс человек

2) **Бинарные** - В таких файлах данные отображаются в виде байтов

---

Пример **текстового** файла:

```text
PassengerId,Survived,Pclass,Name,Sex,Age,SibSp,Parch,Ticket,Fare,Cabin,Embarked
1,0,3,"Braund, Mr. Owen Harris",male,22,1,0,A/5 21171,7.25,,S
2,1,1,"Cumings, Mrs. John Bradley (Florence Briggs Thayer)",female,38,1,0,PC 17599,71.2833,C85,C
3,1,3,"Heikkinen, Miss. Laina",female,26,0,0,STON/O2. 3101282,7.925,,S
4,1,1,"Futrelle, Mrs. Jacques Heath (Lily May Peel)",female,35,1,0,113803,53.1,C123,S
5,0,3,"Allen, Mr. William Henry",male,35,0,0,373450,8.05,,S
6,0,3,"Moran, Mr. James",male,,0,0,330877,8.4583,,Q
7,0,1,"McCarthy, Mr. Timothy J",male,54,0,0,17463,51.8625,E46,S
8,0,3,"Palsson, Master. Gosta Leonard",male,2,3,1,349909,21.075,,S
9,1,3,"Johnson, Mrs. Oscar W (Elisabeth Vilhelmina Berg)",female,27,0,2,347742,11.1333,,S
10,1,2,"Nasser, Mrs. Nicholas (Adele Achem)",female,14,1,0,237736,30.0708,,C
11,1,3,"Sandstrom, Miss. Marguerite Rut",female,4,1,1,PP 9549,16.7,G6,S
12,1,1,"Bonnell, Miss. Elizabeth",female,58,0,0,113783,26.55,C103,S
13,0,3,"Saundercock, Mr. William Henry",male,20,0,0,A/5. 2151,8.05,,S
```

---

Как видите, данные у нас хранятся в человекочитабельном виде

А вот пример того, как выглядит **бинарный файл**.
 
---

```text
\xff\xfe\x00\x00\n\x00\x00\x00C\x00\x00\x00o\x00\x00\x00n\x00\x00\x00t\x00\x00\x00
\x00\x00\x00a\x00\x00\x00r\x00\x00\x00y\x00\x00\x00 \x00\x00\x00t\x00\x00\x00o
x00\x00\x00 \x00\x00\x00p\x00\x00\x00o\x00\x00\x00p\x00\x00\x00u\x00\x00\x00l
x00\x00\x00a\x00\x00\x00r\x00\x00\x00 \x00\x00\x00b\x00\x00\x00e\x00\x00\x00l
x00\x00\x00i\x00\x00\x00e\x00\x00\x00f\x00\x00\x00,\x00\x00\x00 \x00\x00\x00L\
x00\x00\x00o\x00\x00\x00r\x00\x00\x00e\x00\x00\x00m\x00\x00\x00 \x00\x00\x00I\
x00\x00\x00p\x00\x00\x00s\x00\x00\x00u\x00\x00\x00m\x00\x00\x00 \x00\x00\x00i\x
00\x00\x00s\x00\x00\x00 \x00\x00\x00n\x00\x00\x00o\x00\x00\x00t\x00\x00\x00 
\x00\x00\x00s\x00\x00\x00i\x00\x00\x00m\x00\x00\x00p\x00\x00\x00l\x00\x00\x00y\
x00\x00\x00 \x00\x00\x00r\x00\x00\x00a\x00\x00\x00n\x00\x00\x00d\x00\x00\x00o
\x00\x00\x00m\x00\x00\x00 \x00\x00\x00t\x00\x00\x00e\x00\x00\x00x\x00\x00\x00t\
x00\x00\x00.\x00\x00\x00 \x00\x00\x00I\x00\x00\x00t\x00\x00\x00 \x00\x00\x00h\
x00\x00\x00a\x00\x00\x00s\x00\x00\x00 \x00\x00\x00r\x00\x00\x00o\x00\x00\x00o\
x00\x00\x00t\x00\x00\x00s\x00\x00\x00 \x00\x00\x00i\x00\x00\x00n\x00\x00\x00 \x
00\x00\x00a\x00\x00\x00 \x00\x00\x00p\x00\x00\x00i\x00\x00\x00e\x00\x00\x00c\x0
0\x00\x00e\x00\x00\x00 \x00\x00\x00o\x00\x00\x00f\x00\x00\x00 \x00\x00\x00c\
\x00\x00l\x00\x00\x00a\x00\x00\x00s\x00\x00\x00s\x00\x00\x00i\x00\x00\x00c\x00\
x00\x00a\x00\x00\x00l\x00\x00\x00 \x00\x00\x00L\x00\x00\x00a\x00\x00\x00t\x00\x
00\x00i\x00\x00\x00n\x00\x00\x00
```

---

Человек его не поймёт, или же очень (**ОЧЕНЬ**) долго будет понимать-переводить.\
Для наших же машин тут всё просто и понятно.


Так же наши файлы могут быть закодированными в разных кодировках.

```txt
w8Ci9UeXBlIC9TdHJ1Y3RFbGVtCi9TIC9Ob25TdHJ1Y3QKL1AgMTAzIDAgUgovSyBbMTk3IDAg
Ul0KL0lEIChub2RlMDAwMDY1OTYpCj4+CmVuZG9iagoyMyAwIG9iago8PAovVHlwZSAvU3RydWN0RW
xlbQovUyAvTm9uU3RydWN0Ci9QIDEwNiAwIFIKL0sgWzE5OCAwIFJdCi9JRCAobm9kZTAwMDA2NjA
wKQo+PgplbmRvYmoKMjQgMCBvYmoKPDwKL1R5cGUgL1N0cnVjdEVsZW0KL1MgL05vblN0cnVjdAov
UCAxMDkgMCBSCi9LIFsxOTkgMCBSXQovSUQgKG5vZGUwMDAwNjYwNCkKPj4KZW5kb2JqCjI1IDAg
b2JqCjw8Ci9UeXBlIC9TdHJ1Y3RFbGVtCi9TIC9Ob25TdHJ1Y3QKL1AgMTEyIDAgUgovSyBbMjAw
IDAgUiAyMDEgMCBSXQovSUQgKG5vZGUwMDAwNjYwOCkKPj4KZW5kb2JqCjI2IDAgb2JqCjw8Ci9Ue
XBlIC9TdHJ1Y3RFbGVtCi9TIC9Ob25TdHJ1Y3QKL1AgMTE1IDAgUgovSyBbMjAyIDAgUl0KL0lEIC
hub2RlMDAwMDY2MTIpCj4+CmVuZG9iagoyNyAwIG9iago8PAovVHlwZSAvU3RydWN0RWxlbQovUy
AvTm9uU3RydWN0Ci9QIDExOCAwIFIKL0sgWzIwMyAwIFJdCi9JRCAobm9kZTAwMDA2NjE2KQo+Pg
plbmRvYmoKMjggMCBvYmoKPDwKL1R5cGUgL1N0cnVjdEVsZW0KL1MgL05vblN0cnVjdAovUCAxMT
ggMCBSCi9LIFsyMDQgMCBSIDIwNSAwIFIgMjA2IDAgUiAyMDcgMCBSXQovSUQgKG5vZGUwMDAwNj
YxNykKPj4KZW5kb2JqCjI5IDAgb2JqCjw8Ci9UeXBlIC9TdHJ1Y3RFbGVtCi9TIC9Ob25TdHJ1Y3
QKL1AgMTE5IDAgUgovSyBbMjA4IDAgUl0KL0lEIChub2RlMDAwMDY2MjEpCj4
```

---

# **Why do we need to use files in our programming?**

Всем программам нужно работать с файлами по разным причинам,\
вот некоторые из них:

1) **Чтение и обработка входных данных:**

Многие программы требуют входных данных для выполнения своих задач.\
Файлы могут содержать эти входные данные, и программы могут прочитать\
данные из файлов для дальнейшей обработки. Например, текстовый файл\
может содержать список имен пользователей, которые программе\
нужно обработать.

2) **Запись результатов работы программы:**

После выполнения программы результаты могут быть сохранены в файл, чтобы\
их можно было использовать позднее или передать другим программам.\
Например, программа для анализа данных может записать результаты своего\
анализа в файл CSV для последующего использования в электронной таблице.
Так же в файлах можно хранить логи системы. Как, что, когда и с чем отрабатывало.


3) **Хранение и обмен информацией между программами:**

Файлы могут служить средством обмена информацией между разными\
программами. Одна программа может создать файл с данными, а другая\
программа может прочитать этот файл и использовать данные в своей\
работе. Например, веб-приложение может сохранять данные пользователя в\
файле, который затем может быть прочитан другой программой\
для обработки или анализа.

 
# **File Scopes:**

1) **Обработка текстовых данных:**

Программы могут читать текстовые файлы для анализа или обработки текста.\
Какой-нибудь скриптик в машинном обучении может принимать на вход\
какой-нибудь **CSV** с большим количеством данных, для обучения на этих данных.

2) **Работа с базами данных:**

Базы данных часто используются для хранения больших объемов данных.\
Программы могут читать и записывать данные в базы данных через файлы\
(какая-нибудь программа учета продаж может использовать файл базы\
данных для сохранения информации о продажах и клиентах)

3) **Обмен данными с внешними устройствами:**

Файлы могут использоваться для обмена данными с внешними устройствами,\
такими как считыватели штрих-кодов или устройства измерения. (программа\
управления складом может использовать файл, чтобы получать данные о\
товарах, прочитанных с помощью сканера штрих-кодов)

4) **Хранение конфигурационных данных:**

Многие программы используют файлы для хранения настроек и конфигурации.\
(веб-сервер может использовать файл конфигурации для указания порта, на\
котором он будет слушать запросы. В проекте будут лежать разного рода\
файлы конфигураций для настройки работы вашего проекта\приложения.\
При запуске вашего проекта\приложения система будет лезть в эти\
файлы, читать конфиг настройки и запускаться)


**Какие операции с файлами мы можем использовать?**

* **Открытие файла**
* **Закрытие файла**
* **Чтение \ запись файла**

---

# **.TXT files**

простейший формат хранения текста, его преимущество в том, что конвертировать его\
можно практически в любой другой текстовый файл. Однако читать его неудобно\
из-за того, что форматирование практически отсутствует, шо геморно

Что ж, давайте разбираться с нашими текстовыми файлами и методами работы с ними

# **Read operations**

1) **Открытие файла в режиме чтения:**

Для начала чтения файла необходимо открыть его с помощью функции **open()**\

Функция **open()** принимает два аргумента: имя файла и режим доступа.
Режим доступа **'r'** указывает, что файл открывается в режиме чтения:

```python
my_file = open('example.txt', 'r')
```

**Какие методы чтения есть:**

* **read(size=-1)** - используется для чтения данных из файла. Если вызвать **read()**\
без аргументов или с аргументом **-1**, он прочитает весь файл до конца и вернёт его\
содержимое в виде одной строки (для текстовых файлов) или в виде байтов
(для бинарных файлов).                                                                                    

```python
content = my_file.read(size=-1)
print(content)
content.close()
```

Метод **read()** может принимать один опциональный аргумент:\
* `size:` Целое число, которое указывает количество байт, которое нужно\
прочитать. Функция прочитает не более `size` байт и вернёт их.
При каждом вызове метода `read(size)` файла, будет прочитано количество байт,\
равное указанному в `size`. Если данных в файле осталось меньше, чем `size`, будет\
прочитан оставшийся объём данных, а при следующем вызове метод вернёт пустую строку,\
сигнализируя о том, что конец файла достигнут.

Это может быть полезно, если вам нужно прочитать только начало файла или\
если файл слишком большой и читать его целиком может быть проблематично/

```python
file_path = 'your_file.txt'  # путь к файлу
chunk_size = 1024  # Размер чанка в байтах

my_file = open(file_path)

while True:
    data = my_file.read(chunk_size)
    if not data:
        break
```

**Важные замечания**:

* При чтении больших файлов необходимо учитывать объём доступной памяти.\
Если файл превышает размер доступной памяти, попытка прочитать его целиком\
с помощью **read()** может привести к исчерпанию ресурсов.
* После каждого вызова **read()**, файловый указатель перемещается на количество\
прочитанных байт, так что последующий вызов **read()** будет продолжать\
чтение с того места, где остановился предыдущий.
* Если файл открыт в текстовом режиме, **read()** возвращает строку. Если файл\
открыт в бинарном режиме (с добавлением **'b'** к режиму открытия, например **'rb'**),\
**read()** возвращает объект типа **bytes**.

* **readline()** - читает одну строку из файла и возвращает ее. При\
последовательных вызовах `readline()` будут читаться следующие строки файла.

```python
line = my_file.readline()
print(line)
```

Этот метод часто используется, когда вам нужно обработать файл построчно, например,\
если файл слишком велик, чтобы загружать его целиком в память.

* **readlines()** - читает все строки из файла и возвращает их в виде\
списка строк. Каждый элемент списка представляет одну строку файла.

```python
lines = my_file.readlines()
print(lines)
```

Этот метод удобен, когда вы хотите работать со всеми строками файла сразу,\
например, для их последующей обработки в цикле.

---

Еще один способ прочитать содержимое файла - это использовать цикл для\
итерации по файловому объекту. В этом случае каждая итерация\
возвращает одну строку файла.

```python
for line in my_file:
    print(line.strip())
```

# **Close**

После окончания чтения файла необходимо закрыть его с помощью\
метода **close()**. Закрытие файла освобождает ресурсы и предотвращает\
возможные проблемы при дальнейшей работе с ним

`close()` является важной частью правильного управления ресурсами.\
Когда вы открываете файл с помощью функции **open()**, вы создаёте связь между\
вашей программой и файлом на диске. Это соединение требует системных ресурсов\
и блокирует другие операции, которые могут быть выполнены с файлом.

**Если вы не закроете файл с помощью метода **close()**, могут возникнуть\
несколько проблем:**

* **Утечка ресурсов**: Каждый открытый файл использует системные ресурсы, и\
система может ограничивать количество файлов, которые могут быть открыты\
одновременно. Незакрытые файлы могут привести к исчерпанию этих ресурсов,\
что может помешать вашей программе (или другим программам) открывать\
новые файлы.

* **Несохранённые данные**: При записи данных в файл Python использует буферизацию,\
что означает, что данные могут быть временно сохранены в памяти до того, как они\
физически будут записаны на диск. Если файл не закрыть, некоторые данные могут\
так и остаться в буфере и не быть записаны, что приведёт к потере данных.

* **Блокировка файлов**: На некоторых операционных системах открытые файлы могут быть\
заблокированы, что предотвращает их удаление или изменение другими процессами. Это\
может вызвать конфликты в системе, особенно если другие процессы или пользователи\
попытаются работать с этими файлами

* **Непредсказуемое поведение**: Некоторые системы могут автоматически закрывать файлы\
при завершении программы, но это поведение не гарантировано и может отличаться в\
разных средах. Таким образом, полагаться на автоматическое закрытие файлов\
не рекомендуется.

Чтобы избежать этих проблем, рекомендуется всегда закрывать файлы с помощью метода\
**close()**, либо, что ещё лучше, использовать контекстный менеджер `with`, который\
автоматически закрывает файл после выхода из блока `with`, даже если во время\
выполнения кода произошло исключение.



```python
my_file.close()
```

# **Write operations**                                                                                           

Запись в файл позволяет программе сохранять данные или результаты\
своей работы в файле.

1) **Открытие файла в режиме записи:**

Чтобы начать запись в файл, его необходимо открыть с помощью функции\
**open()** с указанием режима доступа **'w'** (запись) или **'a'**(добавление).

Режим **'w'** открывает файл для записи, при этом если файл уже существует,\
его содержимое будет ПЕРЕЗАПИСАНО.

Режим **'a'** открывает файл для добавления новых данных в конец файла,\
при этом существующее содержимое файла сохраняется
 
```python
file_ = open('/content/example.txt', 'w')
```

**Методы записи данных:**

* **write()** - позволяет записать строку **string** в файл. Если файл был открыт в\
текстовом режиме, **string** должна быть типа `str`. Если в бинарном режиме,\
**string** должна быть типа `bytes`.\

```python
file_.write('Hello, world!\n')
```

При использовании режима `w` файл будет очищен перед записью, т.е. все предыдущие\
данные будут удалены. Если вы хотите добавить данные в конец файла,\
используйте режим `a`.

* **writelines()** - предназначен для записи списка строк **lines** в файл. Этот метод\
не добавляет автоматически символы новой строки между строками,\
поэтому если они необходимы, их нужно включать в строки списка.

```python
lines = ['Line 1\n', 'Line 2\n', 'Line 3\n']
file_.writelines(lines)
```

```python
us_name = input("Enter your name: ")

some_file = open("example.txt", "w")

some_file.write(f"Hello, {us_name}!\n")

some_file.close()
```

* **flush()** - используется для "**принудительной**" записи данных из буфера\
в файл, не закрывая сам файл. Это может быть полезно, если вы хотите убедиться,\
что данные записаны на диск, но при этом собираетесь продолжить использовать\
файл далее в коде.

**Буферизация** - это процесс, при котором выходные данные, предназначенные для\
записи в файл, временно хранятся в памяти. Это увеличивает эффективность записи,\
поскольку операции записи на диск выполняются более крупными блоками,\
вместо множества мелких операций.

**Python** автоматически буферизует выходные данные при записи в файлы, но\
иногда нужно управлять этим процессом вручную.

```python
# Открыть файл для записи
file_ = open('example.txt', 'w')
# Записать данные в файл
for i in range(10):
    file_.write(f'Строка номер {i}\n')
    # Принудительно записать данные из буфера в файл
    file_.flush()
    # все незаписанные данные будут записаны на диск

file_.close()
```

В этом примере после каждой записи строки мы вызываем `flush()`, чтобы данные сразу\
же были записаны на диск. Это может быть необходимо, если ваша программа может\
неожиданно завершиться и вы хотите минимизировать потерю данных. Однако частый\
вызов `flush()` может снизить производительность из-за увеличения количества\
операций записи на диск.

Обычно `flush()` используется в ситуациях, когда точность и сохранность данных\
важнее производительности, например, в бухгалтерских системах или при записи\
логов важных системных событий. В большинстве же случаев **Python** достаточно\
эффективно управляет буферизацией самостоятельно, и вам не придётся вручную\
использовать `flush()`.

И не забывайте, что по окончании работы с файлами их обязательно нужно закрывать!

Для этого есть метод **close()**

**Важные замечания**

* После записи данных в файл, особенно при использовании буферизации, может\
потребоваться вызов метода **flush()** для гарантии, что все данные были\
физически записаны на диск.

* Если вы пишете данные в файл в цикле или после выполнения множества операций\
записи, может быть полезно использовать **flush()**, чтобы минимизировать потерю\
данных в случае ошибки программы или сбоя системы.

* При работе с большими файлами или в условиях, когда время доступа к диску\
является критичным фактором, следует внимательно относиться к количеству\
операций записи и моментам их выполнения.

---

# **!!!**
Если файл открывается в неправильной кодировке, тогда требуется\
указать параметр **encoding='utf-8'**


**Какие режимы открытия наших файлов существуют:**

---
| Режим | Обозначение                                                                                           |
|-------|-------------------------------------------------------------------------------------------------------|
| 'r'   | открытие на чтение (является значением по умолчанию)                                                  |
| 'w'   | открытие на запись, содержимое файла удаляется. <br/>Если файла не существует - создаётся новый файл. |
| 'x'   | открытие на запись, создание нового файла. Если файл существует - исключение.                         |
| 'a'   | открытие на дозапись. Информация добавляется в конец файла.                                           |
| 'b'   | открытие в двоичном виде/режиме/формате.                                                              |
| 't'   | открытие в текстовом режиме. (является значением по умолчанию)                                        |
| '+'   | открытие на чтение и запись.                                                                          |
---

Все эти режимы могут объединяться. Например режим **'rb'** - чтение\
в двоичном режиме. По умолчанию режим равен **'rt'**.


```
Открыть файл для записи и записать в него текст пользователя.                                
Каждое предложение на на новой строке.                                
В конце закрыть файл.                               
```

```
Открыть файл для чтения и вывести его содержимое на экран.                                   
```

```
Открыть файл для добавления и добавить новый текст пользователя в конец файла.                                       
```

---

# **With**

Метод работы с файлами через **<your_variable_name> = open(<file_name>, <open_mode>)**\
является устаревшей и может встретиться вам реже, чем вы могли бы подумать.\
На данный момент работы с файлами проводятся благодаря\
контекстному менеджеру **with**\

Контекстный менеджер в **Python** — это объект, предназначенный для управления контекстом\
выполнения блока инструкций, обычно с применением операторов **with**. Ключевым моментом\
использования контекстного менеджера является автоматическое управление ресурсами: их\
получение перед началом блока **with** и освобождение после его выполнения.


При работе с файлами контекстный менеджер **with** гарантирует, что файл будет корректно\
закрыт после того, как выполнение кода внутри блока **with** будет завершено, независимо\
от того, произошло исключение или нет. Это предотвращает утечку ресурсов и гарантирует,\
что все операции с файлом будут должным образом завершены.

```python
with open("/content/example.txt", "w") as data:
  data.write("Hello, World!!!\nWe're in file!")
```

Мы так же можем работать с нашими файлами в контексте циклов:

```python
with open("/content/example.txt", "r+") as data_1:
  for row in data_1.readlines():
    # print(row) # выведет нам наши строки, но с одной пустой строкой, так как мы передавали ещё и разделитель \n
    print(row[::-1].strip()) # выведет нам только наши строки, удаля при этом пустую
```

**Что на счёт записи данных в наш файл через контекстный менеджер?**\


```python
user_name = input("Enter your name: ")
user_age = input("Enter your age: ")
user_job = input("Enter your current job: ")

data_to_write = f"User's name: {user_name}\nUser's age: {user_age}\nUser's current job: {user_job}\n"

with open("user_info.txt", "w") as user_info:
  user_info.write(data_to_write)
```

```python
with open("user_info.txt", "r") as user_info_1:
  for row in user_info_1:
    print(row.strip())
```

Так же мы можем работать и с картинками, видео и прочим при работе\
с нашими файлами

```python
import requests

url = "https://i.pinimg.com/564x/e6/f8/97/e6f89712f5679ecc248b8664f93d5f5d.jpg"

response = requests.get(url)

with open("moonlight.jpg", "wb") as pic_downloader:
  pic_downloader.write(response.content)
```

```python
import pytube
import io

# Ввод URL-адреса видео
video_url = "https://www.youtube.com/watch?v=oZzorKHnFgA"

# Ввод пути и имени файла для сохранения
file_path = "downloaded_video.mp4"
try:
    youtube = pytube.YouTube(video_url)
    video = youtube.streams.first()

    buffer = io.BytesIO()

    video.stream_to_buffer(buffer)

    with open(file_path, "wb") as file_:
      file_.write(buffer.getbuffer())
    
    print('Видео успешно загружено!')
except Exception as e:
    print({
        "error message": "Произошла ошибка при загрузке видео",
        "error info": f"{e}"
    })
```

---

# **Tasks**

```
Написать код, который будет записывать каждый шаг из игры с угадыванием числа в                            
файл "example.log"                                    
```

```python
import random
from datetime import datetime

try:
    max_attempts = int(input("Введите количество попыток: "))
    min_range = int(input("Введите начало диапазона: "))
    max_range = int(input("Введите конец диапазона: "))

    secret_number = random.randint(min_range, max_range)

    attempts = 0
    while attempts < max_attempts:
        guess = int(input(f"Попробуйте угадать число (попытка {attempts + 1}): "))

        if guess == secret_number:
            print(f"Поздравляем! Вы угадали число за {attempts} попыток.")
            break
        elif guess < secret_number:
            print("Загаданное число больше.")
        else:
            print("Загаданное число меньше.")

        attempts += 1
    else:
        print(f"Игра окончена. Вы исчерпали все попытки. Загаданное число было {secret_number}.")

except ValueError:
    print("Ошибка: Введите корректное целое число.")
```

```
Есть файл titanic.txt. Нужно открыть его и вывести содержимое.
```

```
Из уже существующего файла titanic.txt посчитайте количество строк и выведите их.
```

```
Откройте существующий файл titanic.txt, запишите последние две             
строки из этого файла в новый файл some_info_about_titanic.txt
```

```
Пользователь вводит разные данные с клавиатуры. Если он вводит                  
строку - записать её в файл user_response.txt. Если вводит число - пропускать его.
```

```
Считайте лог-файл 'requests.log', а затем проанализируйте его, выводя количество            
запросов по каждому IP-адресу.
```

```
Есть файл log.txt. Откройте его, найдите только строки, в которых                  
выведены ошибки. Эти строки запишите в отдельный файл errors.txt
```
