# **Loops**

**Циклы** - это важная часть программирования, которая позволяет выполнять\
один и тот же блок кода несколько раз. Они особенно полезны, когда вам\
нужно обработать данные, повторить определенное действие или выполнить\
итерацию через элементы в структурах данных.

**Какой синтаксис написания циклов:**

```python
for <local_variable> in <iterable_object>:
    <some code>
```

```python
for i in range(1, 11):
    print(f" Hello, World!!! - - - - - {i}")
```

**Немного общих понятий:**

* **Цикл** - это процесс повторения какого-либо действия или обход\
по какому-нибудь итерированному объекту.

* **Итерируемый объект** – это объект, у которого можно брать элементы\
по одному (строки, списки, кортежи, множества, словари и др).

* **Итерация** - это шаг или организация обработки данных, таким образом,\
когда действие происходит многократно.


**Области применения наших циклов:**

1) **Обработка итерируемых объектов**: Циклы позволяют проходить по элементам\
итерируемых объектов, таких как **списки**, **кортежи**, **строки** и **словари**,\
и выполнять некоторые действия для каждого элемента.

```python
string = "qwerty"

# для буквы в строке:
for letter in string:
  print(f"The iteration number: {string.index(letter) + 1}, the 'letter' value: {letter}")
```

2) **Выполнение блока кода заданное количество раз**: Циклы могут быть\
использованы для выполнения определенного блока кода заданное количество\
раз. Например, когда нам нужно повторить операцию 10 раз или пока не\
будет выполнено определенное условие.


```python
# построить треугольник
spec_symbol = "*"

for i in range(1, 6):
  print(spec_symbol * i)
```

```python
some_value = 5

for i in range(1, 6):
  print(some_value ** i)
```

3) **Обработка данных:** Циклы позволяют нам обрабатывать данные,\
вводимые пользователем, из файла или полученные из другого источника.

---

**Разновидности циклов и их отличия**

**В целом у нас таки два вида циклов:**

* `for`:
    * Срабатывающий определенное количество раз
    * Есть параметр(ы)
    * Известно количество итераций
* `while`:
    * работает по какому-то условию (пока оно True)
    * неизвестное количество итераций (пока условие верно цикл будет выполняться)

---

# **FOR**

Наш цикл **for** работает с итерируемыми объектами.


**Разберём его чуть детальнее:**

```python
for <local_variable> in <iterable_object>:
  <your code block with\without local variable>
```

* `for` - определение того, что сейчас будет цикл
* `local_variable` - локальная переменная, которая создаётся для\
хранения значения из объекта на каждой итерации. Каждую след\
итерацию в этой переменной храниться обновлённое значение.
* `in` - говорит нашему циклу, по какому объекту мы будем проходиться\
этим самым циклом (в рамках какого объекта будет работать цикл)
* `<iterable_object>` - объект, по которому мы будем проходиться\
и что-то с ним делать.
* `<your code block>` - блок кода, в котором будут происходить\
какие-то манипуляции со значениями из объекта


Наша локальная переменная `local_variable` в рамках нашего цикла может\
обзываться как угодно. Общепринято называть эту переменную логически\
подвязаной к нашему итерируемому объекту


**Давайте попробуем что-нибудь написать:**

нужно ввести числа через запятую, дальше все чётные числа нужно возвести\
в квадрат, все нечётные - вычесть корень


Есть некие уникальные айдишники, записанные в множестве.\
Нужно сконвертировать все эти айдишники в строки. Исходные данные\
НЕ должны быть изменены.


Есть строка                                       
```python
some_string = "njk23@&#^masndi0u132wa}dda<nuj*>?gb?gasd?"
```
Необходимо отделить числа, символы, буквы. Всё отдельно в разные\
строки.

---

Обход циклом по таким коллекциям, как **списки**, **строки**,\
**кортежи** и **множества** очень похож друг на друга. А вот со\
**словарями** уже всё более интересно.
Там мы можем пройтись циклом просто по словарю. В таком случае по дефолту\
мы будем проходиться по **ключам** нашего словаря:


```python
my_dict = {
    "a": 1,
    "b": 2,
    "c": 3
}

for elem in my_dict:
  print(elem)

# for key, value in my_dict: получите в лицо ошибку, связанную с                                  
# распоковкой ваших значений из словаря print(key, value)
```


Так же мы можем проходиться только по **ключам**:

```python
my_dict = {
    "a": 1,
    "b": 2,
    "c": 3
}

for key in my_dict.keys():
  print(key)
```


Только по **значениям** ключей:

```python
my_dict = {
    "a": 1,
    "b": 2,
    "c": 3
}

for value in my_dict.values():
  print(value)
```

И по цельным **парам** - ключ: значение:

```python
my_dict = {
    "a": 1,
    "b": 2,
    "c": 3
}
#w [('a', 1), ('b', 2), ('c', 3)]
for key, value in my_dict.items():
  print(key, value)
```

Так же бывают моменты, когда нам не нужно проходиться циклом по\
какому-то объекту, а просто сделать какое-то действие несколько раз\
подряд. В таком случае мы можем передавать в цикл просто объект **range()**:

```python
for _ in range(1, 11):
  print("Some really needed info")
```

Эта функция позволяет нам создавать в моменте какую-то последовательность\
и "лениво" возвращать из неё элементы. У функции `range` можно указывать\
три атрибута:
* `start` - позваляет нам указать откуда начнётся генерация значений
* `stop` - позваляет нам указать до какого элемента, не включая его самого\
будет идти генерация значений
* `step` - позваляет нам указать периодичность взятия элементов и так же\
определить направление генерации (слева направо, справа налево)


Функция `range` так же прекрасно сочетается с `len`, когда мы хотим работать\
по индексам наших элементов. При таком подходе у нас остаётся доступ как к\
индексам, так и к самим элементам:

```python
some_fruits: list = ["Apple", "Banana", "Peach", "Watermelon", "Blueberry"]

for index in range(len(some_fruits)):
    print(f"Позиционный индекс элемента '{some_fruits[index]}' ----- {index}")
```

Для работы одновременно и с индексами, и с самими элементами так же существует\
достаточно "элегантная" и удобная функция в python - `enumerate()`
Эта функция принимает в себя последовательность и создаёт специальный объект-итератор\
внутри которого содержатся парные элементы в кортежах. В этих кортажах обычно ровно\
два элемента находится: `(index, elem)`. Берётся наш элемент, смотрится его индекс\
и как раз на основе этих значений и создаётся пара для кортежа.

Этот итератор можно вставлять в цикл `for` и работать с этими парами через локальные\
переменные цикла. Таким образом механика остаётся всё ещё неизменной как и при\
работе с `range(len())`

```python
for index, item in enumerate(some_fruits):
    print(f"Позиционный индекс элемента '{item}' ----- {index}")
```


В циклах так же есть специальный инструмент, позволяющий останавливать\
весь цикл, и инструмент, позволяющий пропускать текущую итерацию.\
Давайте посмотрим на них:

* **break** - полностью останавливает весь цикл. Удобен в использовании,\
когда при выполнении конкретного условия нужно полностью остановить\
выполнение цикла.

* **continue** - позволяет пропустить текущую итерацию и перейти сразу к\
следующей.


# **Tasks**

---
1. Напишите программу, которая запрашивает у пользователя список чисел и\
затем запрашивает число для поиска. Используйте цикл для поиска числа в\
списке. Если число найдено, прервите цикл с помощью **break**, иначе\
выведите сообщение о том, что число не найдено.

2. Вывод нечетных чисел: Напишите программу, которая выводит все числа\
от 1 до 10, кроме четных. Используйте цикл для перебора чисел и\
оператор **continue**, чтобы пропустить четные числа и продолжить\
вывод только нечетных.

3. Поиск уникальных элементов:
Создайте список, содержащий несколько элементов. Используйте цикл для\
создания нового списка, который будет содержать только уникальные\
элементы из исходного списка (без повторений).

4. Работа с исключениями:
Напишите небольшую "игру" на угадывание числа. Пользователь должен\
ввести 1) колличество попыток 2) диапазон загадывания числа для робота.\
Нужно угадать число, которое загадает робот. Если всё ок - вывести\
сообщение с победой и остановить цикл. Если нет - вывести соответствующее\
сообщение. Обработать возможные ошибки.
---

# **Nested loops**

вы можете вкладывать один цикл внутри другого. Это называется вложенными\
циклами. Это может быть полезно для обработки двумерных структур данных\
или выполнения сложных многократных операций.


Давайте посмотрим как они могут работать. Здесь шо, собсна, происходит:\
у нас есть список со списками, мы влетаем в главный список первым циклом\
берём первый элемент (а это список), и входим в него вторым, вложенным\
циклом. Как только мы пройдём все элементы этого внутреннего списка,\
закончился только **ПЕРВАЯ ИТЕРАЦИЯ** внешнего цикла.


```python
some_values = [
  [1, 2, 3],
  [3, 4, 5],
  [5, 6, 7],
  [7, 8, 9],
  [9, 10, 11]
]
new_list = []

for value in some_values:
  for num in value:
    new_list.append(num ** 2)

print(new_list)
```

Напишем небольшой код на поиск элемента в матрице. Ввести координаты,\
по которым находится элемент.

```python
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
```

**Работа циклов с вложенными элементами**

вы можете итерировать по элементам словаря и работать с его\
ключами и значениями с помощью цикла `for`. Вложенные словари могут\
быть использованы для представления сложных структур данных.


Есть список фильмов:
```python
films = {
    "Парасайт": {
        "рейтинг": 8.6,
        "описание": "Триллер о семье, внедрившейся в дом богатой семьи",
        "год выпуска": 2019,
        "актёрский состав": ["Сон Кан Хо", "Ли Сон Кён"],
        "продолжительность": 132
    },
    "Ирландец": {
        "рейтинг": 7.9,
        "описание": "Эпическая история о жизни наемного убийцы",
        "год выпуска": 2019,
        "актёрский состав": ["Роберт Де Ниро", "Аль Пачино"],
        "продолжительность": 209
    },
    "1917": {
        "рейтинг": 8.3,
        "описание": "Драма о миссии спасения во времена Первой мировой войны",
        "год выпуска": 2019,
        "актёрский состав": ["Джордж Маккей", "Дин-Чарльз Чепмен"],
        "продолжительность": 119
    },
    "Паразиты": {
        "рейтинг": 8.6,
        "описание": "Заводная комедия о семье безработных и их хитроумных планах",
        "год выпуска": 2019,
        "актёрский состав": ["Чхве Ву Чжик", "Сон Кан Хо"],
        "продолжительность": 132
    },
    "Достать ножи": {
        "рейтинг": 7.8,
        "описание": "Черная комедия о группе друзей и их странных приключениях",
        "год выпуска": 2019,
        "актёрский состав": ["Дэниэл Крэйг", "Анна де Армас"],
        "продолжительность": 130
    },
    "Джокер": {
        "рейтинг": 8.5,
        "описание": "Темная драма о происхождении злодея из мира комиксов",
        "год выпуска": 2019,
        "актёрский состав": ["Хоакин Феникс", "Роберт Де Ниро"],
        "продолжительность": 122
    },
    "Пианист": {
        "рейтинг": 8.5,
        "описание": "Драма о выживании пианиста во времена Второй мировой войны",
        "год выпуска": 2002,
        "актёрский состав": ["Адриан Броуди", "Томас Кречман"],
        "продолжительность": 150
    },
    "Зеленая книга": {
        "рейтинг": 8.2,
        "описание": "Дружеское путешествие чернокожего музыканта и белого водителя в 1960-е годы",
        "год выпуска": 2018,
        "актёрский состав": ["Махершала Али", "Вигго Мортенсен"],
        "продолжительность": 130
    },
    "Ла-Ла Ленд": {
        "рейтинг": 8.0,
        "описание": "Мюзикл о любви молодых художников в Лос-Анджелесе",
        "год выпуска": 2016,
        "актёрский состав": ["Райан Гослинг", "Эмма Стоун"],
        "продолжительность": 128
    },
    "Темный рыцарь": {
        "рейтинг": 9.0,
        "описание": "Супергеройский боевик о Бэтмене и Джокере",
        "год выпуска": 2008,
        "актёрский состав": ["Кристиан Бэйл", "Хит Леджер"],
        "продолжительность": 152
    }
}
```
отфильтровать его по рейтингу (вывести только те, у которых рейтинг > 8.5)\
вывести только те фильмы, в которых снимался определённый актёр.

---

есть словарь с книгами:
```python
library = {
    "Принцип оборотня": {
        "автор": "Анджелика Варум",
        "год издания": 2007,
        "город издания": "Москва",
        "краткое описание": "Мистический роман о тайнах оборотней и вампиров",
        "жанр": "Фэнтези",
    },
    "Ведьмак": {
        "автор": "Анджей Сапковский",
        "год издания": 1993,
        "город издания": "Варшава",
        "краткое описание": "Приключенческая фэнтези-сага о ведьмаке Геральте",
        "жанр": "Фэнтези",
    },
    "Гарри Поттер и философский камень": {
        "автор": "Джоан Роулинг",
        "год издания": 1997,
        "город издания": "Лондон",
        "краткое описание": "Приключенческая история о юном волшебнике Гарри Поттере",
        "жанр": "Фэнтези",
    },
    "Атлант расправил плечи": {
        "автор": "Айн Рэнд",
        "год издания": 1957,
        "город издания": "Нью-Йорк",
        "краткое описание": "Философский роман о креативных гении и капитализме",
        "жанр": "Философия",
    },
    "Война и мир": {
        "автор": "Лев Толстой",
        "год издания": 1869,
        "город издания": "Москва",
        "краткое описание": "Эпический роман о судьбах русской аристократии во времена Наполеоновских войн",
        "жанр": "Историческая проза",
    },
    "1984": {
        "автор": "Джордж Оруэлл",
        "год издания": 1949,
        "город издания": "Лондон",
        "краткое описание": "Антиутопический роман о тоталитаризме и контроле над людьми",
        "жанр": "Фантастика",
    },
    "Мастер и Маргарита": {
        "автор": "Михаил Булгаков",
        "год издания": 1967,
        "город издания": "Москва",
        "краткое описание": "Философский и аллегорический роман о дьяволе и литературной Москве",
        "жанр": "Магический реализм",
    },
    "Гордость и предубеждение": {
        "автор": "Джейн Остин",
        "год издания": 1813,
        "город издания": "Лондон",
        "краткое описание": "Роман о любви и социальных нормах английского общества начала XIX века",
        "жанр": "Классическая проза",
    },
    "Три товарища": {
        "автор": "Эрих Мария Ремарк",
        "год издания": 1936,
        "город издания": "Цюрих",
        "краткое описание": "Роман о дружбе и любви трех друзей в Германии после Первой мировой войны",
        "жанр": "Роман",
    },
    "Маленький принц": {
        "автор": "Антуан де Сент-Экзюпери",
        "год издания": 1943,
        "город издания": "Нью-Йорк",
        "краткое описание": "Философская сказка о дружбе и жизни на других планетах",
        "жанр": "Философская проза",
    },
    "Гарри Поттер и Кубок огня": {
        "автор": "Джоан Роулинг",
        "год издания": 2000,
        "город издания": "Лондон",
        "краткое описание": "Приключенческая история о Гарри Поттере и Волшебном Кубке",
        "жанр": "Фэнтези",
    },
    "Сумерки": {
        "автор": "Стефани Майер",
        "год издания": 2005,
        "город издания": "Нью-Йорк",
        "краткое описание": "Роман о любви между человеком и вампиром",
        "жанр": "Романтическая фантастика",
    },
    "Тень ветра": {
        "автор": "Карлос Руис Сафон",
        "год издания": 2001,
        "город издания": "Барселона",
        "краткое описание": "Мистический роман о загадочной книге и барселонских тайнах",
        "жанр": "Мистика",
    },
    "Пикник на обочине": {
        "автор": "Аркадий и Борис Стругацкие",
        "год издания": 1972,
        "город издания": "Ленинград",
        "краткое описание": "Научно-фантастический рассказ о пикнике и зоне",
        "жанр": "Научная фантастика",
    },
    "Алиса в Стране чудес": {
        "автор": "Льюис Кэрролл",
        "год издания": 1865,
        "город издания": "Лондон",
        "краткое описание": "Сказка о приключениях девочки Алисы в стране чудес",
        "жанр": "Детская литература",
    }
}
```

найти определённую книгу, поменять какое-нибудь поле в ней(обновить информацию).\

---

есть словарь:
```python
passengers = {
    "Иван Иванов": {
        "возраст": 35,
        "гражданство": "Россия",
        "семья": True,
        "последние страны": ["Италия", "Франция", "Испания"]
    },
    "Анна Петрова": {
        "возраст": 28,
        "гражданство": "Россия",
        "семья": True,
        "последние страны": ["Греция", "Турция"]
    },
    "Джон Смит": {
        "возраст": 42,
        "гражданство": "США",
        "семья": False,
        "последние страны": ["Канада", "Мексика"]
    },
    "Елена Козлова": {
        "возраст": 25,
        "гражданство": "Россия",
        "семья": False,
        "последние страны": ["Таиланд", "Камбоджа"]
    },
    "Мария Гонсалес": {
        "возраст": 30,
        "гражданство": "Испания",
        "семья": True,
        "последние страны": ["Франция", "Португалия"]
    },
    "Алексей Петров": {
        "возраст": 40,
        "гражданство": "Россия",
        "семья": True,
        "последние страны": ["Германия", "Чехия"]
    },
    "Людмила Сидорова": {
        "возраст": 45,
        "гражданство": "Россия",
        "семья": False,
        "последние страны": ["Финляндия"]
    },
    "Давид Ким": {
        "возраст": 32,
        "гражданство": "США",
        "семья": False,
        "последние страны": ["Япония", "Корея"]
    },
    "Ольга Иванова": {
        "возраст": 28,
        "гражданство": "Россия",
        "семья": True,
        "последние страны": ["Турция", "Египет"]
    },
    "Марк Смит": {
        "возраст": 29,
        "гражданство": "США",
        "семья": False,
        "последние страны": ["Канада", "Мексика"]
    },
    "Александра Попова": {
        "возраст": 31,
        "гражданство": "Россия",
        "семья": False,
        "последние страны": ["Италия", "Франция"]
    },
    "Ирина Маркес": {
        "возраст": 27,
        "гражданство": "Испания",
        "семья": True,
        "последние страны": ["Греция", "Турция"]
    },
    "Петр Козлов": {
        "возраст": 38,
        "гражданство": "Россия",
        "семья": True,
        "последние страны": ["Испания", "Португалия"]
    },
    "Наталья Петрова": {
        "возраст": 40,
        "гражданство": "Россия",
        "семья": True,
        "последние страны": ["Франция", "Германия"]
    },
    "Кристина Ли": {
        "возраст": 26,
        "гражданство": "США",
        "семья": False,
        "последние страны": ["Италия", "Испания"]
    }
}
```

отыскать только тех пассажиров, которые были в определённой стране.\
удалить их из словаря, вывести удалённых.


# **While**

Некоторые же задачи сложно выполнять просто через цикл **for**, даже с\
учётом различных проверок. Для этого существует цикл **while**.

Из самого названия можно предположить, что итерация цикла у нас\
проходит только ПОКА выполненяется какое-то условие

```python
counter = 0
while counter < 5:
  print("Here we go again")

  counter += 1
```

Как это можно всё прочесть:

* `counter` - специальная переменная-счётчик, отвечающая за то,\
чтобы наш цикл не стал бесконечным
* `while` - ключевое слово цикла
* `<condition>` - спец условие, которое будет проверяться\
на **True** перед проходом каждой итерации
* `<body>` - собственно ваш код, который будет выполняться\
в случае, если ваше условие будет True


Спец переменная не всегда должна быть(или быть именно счётчиком).\
В целом наш цикл **while** должен быть написан так, чтобы в нём\
предусматривался **выход из цикла**.
Если мы не предусмотрим никаких выходов из цикла, чтобы наше\
условие не проходило проверку на **True** - мы получим **бесконечный\
цикл**, а это плохо.

Мы можем переписать нашу игру с угадыванием числа на цикл **while**:

```python
import random

try:
    max_attempts = int(input("Введите количество попыток: "))
    min_range = int(input("Введите начало диапазона: "))
    max_range = int(input("Введите конец диапазона: "))

    secret_number = random.randint(min_range, max_range)

    attempts = 0
    while attempts < max_attempts:
        guess = int(input(f"Попробуйте угадать число (попытка {attempts + 1}): "))

        if guess == secret_number:
            print(f"Поздравляем! Вы угадали число за {attempts} попыток.")
            break
        elif guess < secret_number:
            print("Загаданное число больше.")
        else:
            print("Загаданное число меньше.")

        attempts += 1
    else:
        print(f"Игра окончена. Вы исчерпали все попытки. Загаданное число было {secret_number}.")

except ValueError:
    print("Ошибка: Введите корректное целое число.")
```


# **Tasks**

1) Есть список с объектами в виде учеников:
```python
university_students = [
    {
        "name": "Alex",
        "age": 19,
        "sex": "man",
        "facultet": "math"
    },
    {
        "name": "Ban",
        "age": 18,
        "sex": "man",
        "facultet": "math"
    },
    {
        "name": "Chloe",
        "age": 22,
        "sex": "woman",
        "facultet": "physics"
    },
    {
        "name": "Sasha",
        "age": 21,
        "sex": "woman",
        "facultet": "pcyology"
    },
    {
        "name": "Adam",
        "age": 27,
        "sex": "man",
        "facultet": "biology"
    },
    {
        "name": "Lesya",
        "age": 21,
        "sex": "woman",
        "facultet": "pcyology"
    },
    {
        "name": "Linda",
        "age": 23,
        "sex": "woman",
        "facultet": "geography"
    }
]
```

* Вывести всех студентов мужского пола и женского пола отдельно.\
Посчитать их количество(сколько парней и сколько девушек)
* Вывести всех старше 20-ти лет
* Вывести имена только тех студентов, кто учится на\
математическом факультете


2) Факториал числа
Пользователь должен ввести с клавиатуры положительное, целое число **n**\
Нужно написать програму, которая будет вычислять факториал(произведение\
всех целых чисел от 1 до n) этого числа.

Не забывайте ставить какие-нибудь проверки "на дуркака"(если\
пользователь хочет ввести строку\ничего\пробел)\
Вывести полученный результат на экран.

3) Последовательность фибоначи
Пользователь должен ввести с клавиатуры положительное, целое число **n**\
Написать код, который находит n-ое число в последовательности Фибоначчи.\
( Последовательность Фибоначчи начинается с чисел 0 и 1, а каждое\
последующее число получается путем сложения двух предыдущих)\
Не забываем проверки "на дурака"\
Вывести полученный результат на экран.

4) Вёдра
Есть два ведра:\
Ведро на 3 литра\
Ведро на 5 литров\

Есть неограниченный запас воды

Необходимо при помощи этих вёдер отмерить ровно четыре литра воды

**Можно:**

1) Наливать воду в вёдра\
2) Выливать воду из вёдер\
3) Переливать воду из одного ведра в другое\

**Нельзя:**

Выливать воду частично\
Переливать воду частично\

В пятилитровое "сразу" налить 4 литра воды.
