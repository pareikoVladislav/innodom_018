<!-- TOC -->
* [**Types of functions**](#types-of-functions-)
* [**Generators / iterators**](#generators--iterators-)
* [**Iterators, conclusion:**](#iterators-conclusion-)
* [**Iterators FAQ:**](#iterators-faq-)
* [**Listcomp. Genexp:**](#listcomp-genexp)
* [**Recursions**](#recursions-)
* [**Features of recursive functions in Python**](#features-of-recursive-functions-in-python-)
<!-- TOC -->

# **Types of functions**                                                            

# **Generators / iterators**                                                            

**Итеративный объект** – это объект, по которому можно совершить итерацию.

**Итераторы** – ключевая концепция в Python, которая позволяет перебирать\
элементы коллекции (например, списка или словаря) последовательно,\
не зная заранее, сколько их там.

Вы уже знакомы со способом прохода через цикл. Однако, если в итеративном\
объекте хранится много значений, тогда на помощь приходят функции\
`iter()` и `next()`, которые позволяют не хранить целый объект в памяти,\
а извлекают его и хранят только текущий элемент.


* `iter(obj)` - возвращает объект итератора для объекта.
* `next(iterator)` - возвращает следующий элемент в итераторе.

Когда элементы в итераторе заканчиваются, вызывается\
исключение `StopIteration`.

**Как это выглядит:**

```python
my_list = {"one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}

my_iter = iter(my_list)
print(type(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
# print(next(my_iter))
```

Итераторы полезны, когда мы хотим выполнять итерацию через большие\
или бесконечные коллекции, такие как файлы, базы данных\
или потоки данных.

**Генератор** – это специальный вид итераторов, которые можно\
создать с помощью функций и ключевого слова `yield`.

Генераторы **ленивы**: они генерируют значения по мере необходимости.

```python
def simple_range(end):
    current = 0
    while current < end:
        yield current
        current += 1

for num in simple_range(3):
    print(num)
```

**Почему итераторы важны?**

* **Эффективность**: Итераторы не требуют загрузки всех элементов в\
память сразу. Это особенно полезно при работе с большими данными.

* **Универсальность**: Многие встроенные структуры данных в\
Python (такие как списки или словари) и библиотеки поддерживают итераторы.

  * **Создание пользовательских коллекций**: Вы можете создать свою\
  коллекцию объектов, которая поддерживает итерацию.

**Вот некоторые способы применения генераторов и итераторов:**

* Постепенная обработка больших объемов данных, таких как чтение\
  больших файлов или баз данных по мере необходимости.
* Ленивая загрузка данных из внешних источников.
* Генерация итерируемых последовательностей с определенными\
  правилами или условиями.
* Фильтрация или преобразование элементов в коллекции.
* Рекурсивные итерации без использования рекурсивных вызовов\
  функций, чтобы избежать переполнения стека.


# **Iterators, conclusion:**

Итераторы — это мощный инструмент в Python, позволяющий эффективно и удобно\
работать с коллекциями данных. Благодаря итераторам вы можете создавать\
ленивые вычисления, экономить память и делать ваш код более читаемым.

# **Iterators FAQ:**

* **Чем отличается итератор от итерируемого объекта?**

**Итератор** — это объект, который реализует методы `__iter__()` и `__next__()`.\
Итерируемый объект — это объект, который может возвращать итератор с\
помощью метода `__iter__()`, но сам по себе итератором не является.

* **Что делать, если я хочу перебрать итератор несколько раз?**
Вы можете создать новый итератор или, если это возможно,\
переиспользовать исходный объект для создания нового итератора.


---

**Задача:**
Фильтрация данных из базы данных. Реализуйте функцию-итератор, которая\
позволяет получать только те записи из базы данных, где возраст\
пользователя больше 18. ID этих пользователей записать в список\
`users_white_list` для передачи фронту

```python
database_data = [
    {"id": 1, "username": "user123", "email": "user123@example.com", "age": 25},
    {"id": 2, "username": "john_doe", "email": "johndoe@example.com", "age": 15},
    {"id": 3, "username": "emma_s", "email": "emma_s@example.com", "age": 42},
    {"id": 4, "username": "alex21", "email": "alex21@example.com", "age": 21},
    {"id": 5, "username": "lisa_smith", "email": "lisa.smith@example.com", "age": 30},
    {"id": 6, "username": "max_power", "email": "max_power@example.com", "age": 15},
    {"id": 7, "username": "sara_m", "email": "saram@example.com", "age": 28},
    {"id": 8, "username": "brian88", "email": "brian88@example.com", "age": 33},
    {"id": 9, "username": "julia_c", "email": "juliac@example.com", "age": 17},
    {"id": 10, "username": "sam99", "email": "sam99@example.com", "age": 14},
    {"id": 11, "username": "megan_ross", "email": "megan.ross@example.com", "age": 23},
    {"id": 12, "username": "mark_johnson", "email": "markjohnson@example.com", "age": 17},
    {"id": 13, "username": "amy_w", "email": "amy_w@example.com", "age": 18},
    {"id": 14, "username": "chris25", "email": "chris25@example.com", "age": 25},
    {"id": 15, "username": "natalie_g", "email": "natalieg@example.com", "age": 14},
    {"id": 16, "username": "michael_b", "email": "michaelb@example.com", "age": 19},
    {"id": 17, "username": "lucas34", "email": "lucas34@example.com", "age": 27},
    {"id": 18, "username": "olivia_smith", "email": "olivia.smith@example.com", "age": 14},
    {"id": 19, "username": "david_p", "email": "davidp@example.com", "age": 21},
    {"id": 20, "username": "sophie_w", "email": "sophiew@example.com", "age": 17},
    {"id": 21, "username": "ryan_miller", "email": "ryan.miller@example.com", "age": 35},
    {"id": 22, "username": "lily_g", "email": "lilyg@example.com", "age": 14},
    {"id": 23, "username": "patrick_s", "email": "patricks@example.com", "age": 37},
    {"id": 24, "username": "grace41", "email": "grace41@example.com", "age": 41},
    {"id": 25, "username": "daniel_h", "email": "danielh@example.com", "age": 15},
    {"id": 26, "username": "victoria99", "email": "victoria99@example.com", "age": 24},
    {"id": 27, "username": "jacob_t", "email": "jacobt@example.com", "age": 14},
    {"id": 28, "username": "sophia_c", "email": "sophiac@example.com", "age": 16},
    {"id": 29, "username": "andrew_j", "email": "andrewj@example.com", "age": 23},
    {"id": 30, "username": "emily_rose", "email": "emily.rose@example.com", "age": 17},
]
```
---
**Задача:**
Экспорт данных из JSON в CSV
Написать функцию, которая читает данные из файла **.json** и экспортирует их в файл **.csv**.\
Используйте генератор для эффективной обработки данных.

**Описание задачи:**
Входной файл users_data.json содержит список словарей, где каждый словарь представляет данные\
одного пользователя (например, id, username, email, age).
Напишите функцию json_to_csv(json_file, csv_file), которая читает данные из json_file и записывает\
их в csv_file, используя генератор для обработки данных.
Каждая запись в файле .csv должна содержать те же поля, что и в .json.

---

**Задача:**
Поиск и фильтрация данных в CSV с использованием итератора
Написать функцию, которая использует итератор для поиска и фильтрации записей в файле .csv,\
соответствующих определённому критерию, и возвращает результаты.

**Описание задачи:**
Входной файл users_data.csv содержит данные пользователей (например, id, username, email, age).
Напишите функцию filter_users_by_age(csv_file, age_threshold), которая принимает имя\
файла и пороговое значение возраста, и возвращает список пользователей старше данного возраста.
Используйте функцию next() для итерирования через строки файла .csv, пропуская\
заголовок и обрабатывая данные.


**Задача:**
Генерация уникальных идентификаторов. Напишите генератор, который создает\
уникальные идентификаторы для объектов, добавляемых в систему. Уникальный\
идентификатор может быть строкой или числом и должен гарантировать\
уникальность для каждого нового объекта.

---

# **Listcomp. Genexp:**

`Итеративные и генеративные выражения` – это списковые включения для\
упрощения читабельности и сокращения кода, такие включения можно\
делать для списков, словарей, множеств, генераторов.

**Шаблон спискового включения:**

`[возвращаемое_значение цикл условие_не_обязательно]`

`Итеративное выражение` – это списковое включение, которое работает\
уже с существующим итерируемым объектом.

Итеративные выражения используются для создания итерируемых объектов\
с помощью синтаксиса списка (**list comprehension**).
Они позволяют нам создавать последовательности\
значений на основе других последовательностей или итерируемых объектов.

Итеративные выражения создают новую последовательность значений и могут\
быть преобразованы в конкретные коллекции данных, такие как списки,\
множества или кортежи.

```python
squares = [x**2 for x in range(10)]  # Создает список квадратов чисел от 0 до 9
```

```python
squares = []

for x in range(10):
    squares.append(x ** 2)  # делает ту же работу
```

Условия в итеративных выражениях могут располагаться в двух местах: в конце\
выражения для фильтрации значений, или в начале для определения значения элемента\
на основе условия:

```python
# List comprehension: числа от 0 до 9, которые делятся на 2
evens = [x for x in range(10) if x % 2 == 0]
print(evens)  # [0, 2, 4, 6, 8]


# -----------------------------

events = []

for x in range(10):
    if x % 2 == 0:
        events.append(x)
```

```python
# List comprehension: 'small' для чисел < 5, иначе 'large'
sizes = ['small' if x < 5 else 'large' for x in range(10)]
print(sizes)  # ['small', 'small', 'small', 'small', 'small', 'large', 'large', 'large', 'large', 'large']


# ------------------------------

sizes = []

for x in range(10):
    if x < 5:
        sizes.append('small')
    else:
        sizes.append('large')
```

Итеративные выражения могут содержать вложенные циклы для создания списков с помощью\
перекрестного продукта двух итерируемых объектов.

```python
# Создание списка всех возможных пар чисел из двух списков
pairs = [(x, y) for x in range(3) for y in range(3)]
print(pairs)  # [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]

# ---------------------------

pairs = []

for x in range(3):
    for y in range(3):
        pairs.append((x, y))
```

```python
# Создание списка с условиями до и после цикла
result = ['small' if x < 5 else 'large' for x in range(10) if x % 3 == 0]
print(result)


# --------------------------------

result = []

for x in range(10):
    if x % 3 == 0:
        if x < 5:
            result.append('small')
        else:
            result.append('large')
```

**Генеративные выражения** используются для создания генераторов - итерируемых\
объектов, которые генерируют значения "лениво", по мере необходимости, без\
хранения всех значений в памяти.

Функции-Генераторы используют ключевое слово `yield`, чтобы вернуть значения и\
сохранить состояние выполнения функции.

Генеративные выражения возвращают генераторы, которые могут быть использованы\
в циклах `for` или получать значения с помощью функции `next()`. Они особенно\
полезны, когда требуется работать с большими объемами данных или\
генерировать значения по требованию без необходимости хранения всех\
значений в памяти.

**Синтаксис итеративных и генеративных выражений в `Python` очень**\
**похож, но есть некоторые различия:**

1) **Синтаксис:**
   `Итеративное выражение:` Используется в квадратных скобках `[]` или\
   фигурных скобках `{}` для создания списка или множества.

`Генеративное выражение:` Используется в круглых скобках `()`\
для создания генератора.

2) **Использование:**

`Итеративное выражение:` Создает новую коллекцию данных (список,\
множество и т. д.), которая может быть использована непосредственно.

`Генеративное выражение:` Создает генератор, который генерирует\
значения по требованию и сохраняет состояние выполнения функции.

3) **Хранение значений**

`Итеративное выражение:` Создает и хранит все значения в памяти,\
чтобы вернуть коллекцию данных целиком.

`Генеративное выражение:` Генерирует значения по мере необходимости,\
сохраняя минимальное состояние в памяти.

4) **Использование в циклах:**

`Итеративное выражение:` Можно использовать напрямую в цикле `for`\
для итерации по всем элементам коллекции.

`Генеративное выражение:` Необходимо использовать функцию `next()`\
или включить генератор в цикл `for` для получения значений.

5) **Возможности:**

`Итеративное выражение:` Позволяет преобразовывать и фильтровать\
значения, а также создавать новую коллекцию данных.

`Генеративное выражение:` Позволяет генерировать значения на лету\
и эффективно работать с большими объемами данных.                             


---

**немного практики**

**Создание списка квадратов чисел:**
Через `list comprehension` создать список с числами, где каждое число\
возведено в квадрат

**Фильтрация списка четных чисел:**
Принять от пользователя числа через запятую\
преобразовать их в список чисел\
отфильтровать список через `list comprehansion`                             

**Вычисление суммы квадратов четных чисел:**\
Есть список чисел, вычислить сумму его чётных чисел:

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```
---

# **Recursions**


**Рекурсия** – это подход в программировании, при котором функция вызывает\
сама себя. Любую рекурсивную функцию можно представить как цикл, а\
цикл можно представить как рекурсию.

**Преимущества рекурсии:**

1) каждый новый вызов функции в функции начинается с чистого листа,\
   а значения из предыдущих вызовов отдаются в стек.
2) код, написанный через рекурсию читается проще. Решения выглядит лучше.

**Недостатки рекурсии:**

1) размер стека, которому проталкиваются элементы из каждого\
   вызова не безграничен.
2) рекурсию трудно представить, если рекурсия спроектирована плохо,\
   она может убить ваше приложение или сильно его замедлить.

**Правила создания рекурсий:**

1) рекурсия не должна создавать больше чем 3000 слоев (вызовов)
2) у рекурсии всегда должно быть условие остановки
3) использовать рекурсию, для того чтобы решение становилось меньше и понятнее
4) использовать рекурсию, когда знаешь глубину вызов
5) если код читает другой человек, выбор в пользу рекурсии\
   (код красивее и понятнее)
6) если скорость не так важна выбор в пользу рекурсии                                 

```python
# пример рекурсии

def greeting(value: int) -> None:
    if value == 0:
        return 0
    print(f"Hello! This is recursion! {value}")
    greeting(value - 1)
```

**Основные принципы рекурсивных функций:**

`Базовый случай:` Рекурсивная функция всегда должна иметь **"базовый случай"**\
или **"условие выхода"**, которое определяет, когда рекурсия должна завершиться.\
Этот базовый случай обычно определяется так, чтобы функция не\
вызывала себя бесконечно.

`Рекурсивный случай:` Это шаг, при котором функция вызывает саму себя с\
аргументами, которые приближают к базовому случаю. Это позволяет функции\
продолжать выполнение до тех пор, пока не будет достигнут базовый\
случай и рекурсия завершится.


**Рекурсия** - мощный инструмент в программировании, но её следует\
использовать осторожно, чтобы избежать бесконечных циклов и\
излишних накладных расходов на память.


# **Features of recursive functions in Python**

**Максимальная глубина рекурсии:**

В **Python** есть ограничение на максимальную глубину рекурсии, которое\
определяется максимальным количеством вызовов функции, которые могут быть\
вложены друг в друга. Это ограничение называется "**максимальной глубиной\
стека**" (**maximum recursion depth**).

Значение максимальной глубины рекурсии зависит от конкретной версии\
**Python** и его настроек. В стандартной настройке **Python** это значение\
обычно составляет `1000` вызовов функций.
При превышении максимальной глубины рекурсии **Python** вызовет\
исключение `RecursionError`.

```python
def infinity_recursion(a):
   return infinity_recursion(a + 1)
```

В **Python** можно переопределить максимальное количество вызовов рекурсии,\
изменяя глубину стека с помощью функции `sys.setrecursionlimit()`. Однако\
это не рекомендуется делать без веских причин, так как увеличение глубины\
стека может привести к переполнению стека и ошибкам в работе программы.
Кроме того, стандартное значение глубины стека установлено на определенное\
значение для обеспечения безопасности выполнения программ.

```python
import sys

new_limit = 500  # Новое значение глубины стека
sys.setrecursionlimit(new_limit)

# Теперь можно выполнять более глубокие рекурсивные вызовы
```

Вызов рекурсии может находиться не только в конце функции, но и в любом месте\
функции, в зависимости от логики задачи. Передача управления рекурсивному\
вызову в середине функции вполне допустима, и это может быть полезным\
в некоторых сценариях.

```python
def countdown(n):
    print(n)
    if n > 0:
        countdown(n - 1)
    print("Выполнено для", n)

countdown(5)
```

```python
def factorial(n):
    if n == 0:
        return 1
    else:
        result = factorial(n - 1)
        return n * result

result = factorial(5)
print("Факториал равен:", result)
```

**Вычисление факториала числа.**
Напишите функцию, которая вычисляет факториал числа\
n с использованием рекурсии.


**Подсчет суммы элементов списка.**
Напишите функцию, которая рекурсивно вычисляет сумму\
всех элементов списка целых чисел.

**Вычисление чисел Фибоначчи.**
Напишите функцию, которая рекурсивно вычисляет n-ное\
число в последовательности Фибоначчи.
