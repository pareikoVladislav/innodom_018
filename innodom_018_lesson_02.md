# **Variables**

**Переменная** — это каким-либо образом проименованная и/или адресованная область\
физической или виртуальной памяти. Предназначенна для хранения данных (значений).\
С помощью переменной можно проводить различные операции с данными и обеспечить\
программе необходимую гибкость.


**Переменная** может хранить в себе различные данные ( исходя из задекларированных\
типов данных в определённом языке ). Её можно расценивать, как своего рода коробку, в\
которую мы будем что-то ложить и пользоваться этим в течение "жизни" этой переменной.\
Название такое она получила за счёт того, что значение в ней может меняться\
( как и сам тип данных, но не всегда ).


**Чем же они так "популярны"?**

Представьте, что нам нужно напечатать на экране фразу `"Hello, World!"` два раза.\
Эту задачу можно решить так:

```python
print("Hello, World!")
print("Hello, World!")
```

И в целом это будет работать, почему нет!

А теперь представьте, что у вас есть файл, в котором содержится порядком **1000 строк**\
и такую надпись вы много где используете в этом файле. Уже не так удобно получается,\
верно? Ведь придётся прописывать одно и то же множество раз подряд, что приводит\
к дублированию кода, а это не самая лучшая практика.


**Усложним задачу:**

Всё работает и все довольны, но к вам пришли и сказали, что теперь хотят, чтобы была\
новая фраза: `"Greeting, User!"` Теперь вам придётся проходить **ПО ВСЕМУ** файлу и\
искать места, где появлялась эта фраза и менять её.

А можно создать переменную и поместить в неё наше приветствие, за счёт чего мы\
облегчим задачу себе и не будем нагружать код сотнями повторений:

```python
greeting = "Greeting, User!"

print(greeting)
```

В строчке `greeting = "Greeting, User!"` мы берем переменную с именем `greeting` и\
присваиваем ей значение `"Greeting, User!"`. Переменная указывает на данные,\
которые в неё записали. Благодаря этому данные можно использовать многократно\
и не дублировать их постоянно.


---

![img_3.png](https://raw.githubusercontent.com/pareikoVladislav/innoDom012/main/img_3.png)

---

Когда переменная создана, можно ее использовать. Она подставляется в те места, где\
раньше стояла наша фраза. Когда код выполняется, интерпретатор доходит до строчки\
`print(greeting)` и подставляет содержимое переменной, а затем выполняет код.


# **Rules for creating variables**

**Как же правильно создавать переменные и что нужно учитывать?**


**Идентификаторы** (названия переменных) могут быть комбинацией букв нижнего регистра\
(от `a` до `z`) или прописных (от `A` до `Z`), цифр (от `0` до `9`) или символа\
подчеркивания `_`. Такие имена, как `myClass`, `var_1` и `print_this_to_screen`,\
являются допустимым примером.


* Переменная не может начинаться с цифры.
* Ключевые слова нельзя использовать в качестве идентификаторов
* Мы не можем использовать специальные символы, такие как `!`, `@`, `#`, `$`, `%` и т.д.
* Переменная может быть любой длины ( но лучше не перебарщивать )
* Ваша переменная должна отражать заложенный логический смысл того, что в ней лежит.


Так же стоит учитывать, что переменные в **Python** чувствительны к регистру. Одно и\
то же название переменной в разных регистрах будет разными переменными:

```python
# myAwesomeVariable # camelCase
# my_awesome_variable # snake_case
```

```python
qwe = 5
QWE = 10
Qwe = 15

print(qwe, QWE, Qwe)
```


# **Reserved variable names**

**Ключевые слова** — это зарезервированные слова в **Python**. Мы не можем\
использовать ключевое слово в качестве имени переменной, имени функции или\
любого другого идентификатора. Они используются для определения синтаксиса\
и структуры языка **Python**.

Все ключевые слова, кроме `True`, `False` и `None`, написаны в нижнем регистре\
и должны быть записаны как есть.

Чтобы узнать какие же слова нельзя использовать в качестве переменных,\
можно ввести следующую команду:

```python
help("keywords")
```

---

![img_5.png](https://raw.githubusercontent.com/pareikoVladislav/innoDom012/main/img_5.png)

---

# **How to change variables**

Само слово «переменная» подсказывает, что ее можно менять. И действительно,\
со временем внутри программы значения переменных могут изменяться:

```python
# greeting - переводится как приветствие
greeting = 'The first sample of text'
print(greeting)  # => The first sample of text
```

```python
greeting = 'QWERTY!'
print(greeting)  # => QWERTY!
```

```python
greeting = 123
print(greeting)
```

Обратите внимание, что сама переменная у нас осталось той же,\
поменялось именно её содержимое.

# **Arithmetic operators in Python**

Что у нас собственно по операторам вычислений? В Питоне они следующие:

* `-` — вычитание
* `*` — умножение
* `**` — возведение в степень (а если возвести в степень 0.5, то можно получить       
квадратный корень)
* `/` — деление (при делении чисел получается float)
* `//` — целочисленное деление
* `%` — остаток от деления


Однако и тут не так всё легко, как может показаться. Так же, как и в математике,\
в Питоне есть **приоритетность** для операторов. Вот наша с вам иерархия приоритетов\
от высокого к низкому ( для операторов вычесления ):

* Возведение в степень `**`
* Деление `/` Остаток от деления `%` Умножение `*`
* Вычетание `-` Сложение `+`
* Операторы сравнения `in`, `not in`, `is`, `is not`, `<`, `<=`, `>`, `>=`, `<>`, `!=`, `==`


```python
# Сначала выполняется умножение
# потом операция сложения
# Результат: 17
5 + 4 * 3
```

Так же мы можем определять приоритет сами, взяв нужный нам кусок\
выражения в круглые скобки:

```python
# Круглые скобки () переопределяют приоритет арифметических операторов
# Вывод: 27
(5 + 4) * 3
```

Некоторые группы включают по несколько операторов python. Это значит, что все\
представители одной группы имеют один уровень приоритетности.

При наличии двух или более операторов с одинаковым уровнем в дело вступает\
ассоциативность, определяющая порядок.

Например, у операторов умножения и деления приоритетность одинаковая. В одном\
выражении тот, что находится слева, будет выполняться первым.

```python
# Тестирование ассоциативности слева направо
print(4 * 7 % 3)

print(2 * (10 % 5))
```

---

**Ассоциативность** — это порядок, в котором **Python** выполняет выражения,\
включающие несколько операторов одного уровня приоритетности.

**Неассоциативные операторы**

Наши с вами операторы сравнений не поддерживают ассоциативность. Для\
них применяются специальные правила порядка, в которых ассоциативность\
НЕ принимает участия.

Так же работает связывание операторов присваивания (например, `a=b=c`),\
а вот `a = b += c` вернет ошибку.


```python
a = q = 5
a = 1

print(a)
print(q)
print(id(a))
print(id(q))
```

---

# **Data Typing in Python**

Как мы обсуждали ранее, **Python** - язык динамический.

Всякий раз, когда мы пишем программу на **Python**, мы сталкиваемся с разными\
наборами операторов, один из которых является оператором присваивания\
( = ), в котором мы инициализируем переменную со значением.


Когда мы говорим о таких языках, как **C, C++ и Java**, память распределяется на\
основе типа данных переменной, и к ней обращаются соответственно, тогда как python\
является динамически типизированным языком, он сохраняет значение в каком-то\
месте (**в ячейке памяти**), а затем объединяет соответствующее имя\
переменной с контейнером.

Тип данных определяется во время выполнения:

```python
a = 12.0
print(type(a))
b = 24
print(type(b))
c = 'data'
print(type(c))
print(a * 3)
print(b * 3)
print(c * 3)
```

На старте мы инициализируем ( создаём ) три переменные: `a`, `b`, и `c`,\
и присваиваем им наши значения ( дробное число, целое число и строку )

Дальше мы проверяем тип данных наших переменных ( Всё благодаря методу `type()` )\
И после всего этого мы проводим одно и то же действие с нашими переменными - умножаем\
их на тройку. Но результат у нас будет разным, за счёт того, что наш Питон при\
проходе по коду определил тип данных для каждой из переменных. На выходе мы\
молучаем так же дробное число, целое число и строку.

Так же Питон поддерживает такой прекрасный синтаксический сахар ( которым пользуются\
не все к сожалению ), как определение типа переменной в момент\
её определения. Как это работает:

```python
my_int: int = 83
my_string: str = "Hello!"
my_float: float = 4.1
```

Что поменялось: теперь наша переменная имеет очевидный, присвоеный ей тип данных.

Это может помочь разработчику не запутываться в том, а что же у него в переменной\
будет / может лежать и так же предотвратить попадание в эту переменную\
какого-то другого типа данных. Это что касается сред разработки.

---

# **How do variables work?**

Переменная является именованной областью памяти. После того как вы\
дали имя области, появляется возможность обращаться к данным, что в ней хранятся.

Каждый элемент данных в `Python` является объектом определенного типа или\
класса. Когда, в процессе выполнения программного кода, появляется новое значение,\
интерпретатор выделяет для него область памяти — то есть создаёт объект\
определенного типа (число, строка и т.д.). После этого `Python` записывает в\
свой внутренний список адрес этого объекта.

Но как теперь получить доступ к созданному объекту? Для этого и существуют\
переменные — они дают возможность удобно работать с объектами используя\
имена вместо адресов. Проще говоря - наши с вами переменные - просто именна,\
прикреплённые к определённому объекту, в котором лежит что-то, что мы туда положили.


Создадим с вами новую переменную, присвоим ей какое-то значение, а         
после посмотрим на это значение, на его тип и на его ячейку памяти:      

```python
a = 123

print(a)
print(type(a))
print(id(a))
```

В примере выше мы создали переменную a и присвоили ей значение `123`,\
далее вывели ее значение, тип и адрес объекта в памяти.

---

![img_4.png](https://raw.githubusercontent.com/pareikoVladislav/innoDom012/main/img_4.png)

---


Представьте, что у вас есть много непрозрачных бутылок. Вы залили в каждую из\
них разный сок, или напиток и после запечатали все эти бутылки.\
**Резонный вопрос:** как теперь понять содержимое отдельно взятой бутылки?

**Ответ:** предварительно их подписать. Сделав это, вы будете точно знать,\
что находится в бутылках.

Бутылок в какой-то момент у вас становится много и для хранения соков пришлось\
арендовать склад, где каждая бутылка находится строго на своём месте.\
Теперь у вас есть ещё и специальные карточки: на каждой из них записаны название\
сока и адрес этого сока на складе. Когда требуется достать конкретную\
бутылку с соком, вы посмотрите на карточку, прочтёте номер ячейки, а\
затем пойдёте к обозначенному месту на складе и возьмёте оттуда нужную бутылку.


**В данном примере:**
* `переменная` — карточка c конкретной бутылкой с соком;
* `адрес` — это номер ячейки на складе;
* `объект` — сама ячейка;
* `данные` — бутылка с соком внутри.


Чтобы понимать работу переменных нам нужно разобрать, что происходит\
"под капотом" в момент создания новой переменной и присваивания ей значения:

```python
a = 100
```

**Что у нас тут происходит:**

* Создаётся объект типа `int` со значением `100`
* Этот объект записывается в ячейку памяти, которой\
  присваивается уникальный номер
* В переменной `a` сохранится адрес (ссылка) на объект

---

![img_6.png](https://raw.githubusercontent.com/pareikoVladislav/innoDom012/main/img_6.png)

---


Очень важно не забывать, что переменная в Python не хранит\
значение напрямую — она хранит лишь ссылку на объект

Теперь посмотрим что произойдет, если одной переменной присвоить другую переменную:

```python
a = 100
b = a

print(a, b)
print(id(a), id(b))
```

В этом примере Python не создает нам новый объект — он просто создает\
переменную, которая ссылается на тот же объект, что и переменная `a`

---

![img_7.png](https://raw.githubusercontent.com/pareikoVladislav/innoDom012/main/img_7.png)

---

Теперь же давайте глянем, что будет, если мы захотим поменять\
значение для нашей переменной `b`:

```python
a = 300
b = 500

print(a)
print(b)
print(id(a))
print(id(b))
```

В этом примере уже наш `Python` создаёт новый объект типа `int` и присваевает\
ему наше значение. Так как был создан новый объект - у переменной `b` теперь\
своя ячейка памяти:

---

![img_8.png](https://raw.githubusercontent.com/pareikoVladislav/innoDom012/main/img_8.png)

---

Теперь давайте посмотрим ещё один пример: Зададим новое значение нашей переменной `b`:

```python
b = "text"

print(id(b))
```

На объект типа `int` со значением `500` больше не ссылается никакая переменная.\
Следовательно, он больше не доступен и будет удален сборщиком\
мусора (тем самым освободив немного памяти).

---

![img_9.png](https://raw.githubusercontent.com/pareikoVladislav/innoDom012/main/img_9.png)

---

Помните, что Идентификатор объекта — это адрес нашего объекта в памяти.\
В примерах выше мы использовали функцию `id()` Эта функция возвращает число,\
которое является неизменным и уникальным для каждого объекта на протяжении\
его жизненного периода:

```python
q = w = 200

print(id(q))
print(id(w))
print(id(200))
```

---

# **Data Types in Python**

В Python, типы данных могут быть **изменяемыми** и **неизменяемыми**.          

**Неизменяемые** типы данных означают, что значения, которые хранятся        
в таких объектах, не могут быть изменены после создания объекта.         

**Изменяемые** типы данных, напротив, могут изменять значение внутри объекта.          


В целом же наши данные в Python бывают:
* Базовые типы данных(статические)
* Коллекции


К базовым типам данных мы можем отнести:

* **Числовые типы данных**
   * `int`: целочисленные значения
   * `float`: числа с плавающей точкой (дробные числа)
   * `complex`: комплексные числа

* **Логический тип данных**
   * `bool`: логический тип данных

* **Строковый тип данных**
   * `str`: строки

* **NoneType**
   * `None`: тип данных, который указывает на отсутствие значения

Каждый из этих типов данных имеет свои собственные операции, которые можно          
выполнять с помощью встроенных функций и операторов языка Python.


Что же до наших более сложных структур данных - коллекций, тут всё веселее!
Наши коллекции состоят из:

* **Последовательностей** ( индексированные, элементы не уникальны )
   * Изменяемые
      * список(`list`)
   * Неизменяемые
     * строки(`str`)
     * кортежи(`tuple`)

* **Множества** ( неиндексированные, элементы уникальны )
   * Изменяемые
     * множества(`set`)
   * Неизменяемые
     * неизменные множества(`frozenset`)

* **Отображения** ( Неиндексированный набор пар <ключ: значение> )
   * словари(dict)

---

![img_10.png](img_10.png)

---

Чтобы вам было проще запомнить: Изменяемые типы данных - первые буквы           
наших типов данных `List`, `Set`, `Dict` - `LSD`


# **Summary**

Типы данных в Python у нас могут быть изменяемыми и неизменяемыми. К изменяемым          
у нас относятся `List`, `Set`, `Dict` ( `LSD`, не забываем ) Остальные типы данных          
у нас неизменяемые. Так же в этих типах данных у нас имеются категирии:        

`Последовательности` - Это те типы данных, по которым мы можем пройтись циклом,          
у которых есть индексы. 

`Множества` - типы данных, являются неиндексируемыми, значения в них являются         
уникальными. 

`Отображения` - набор данных в формате `ключ: значение`


```python
# int
int_var = -9
```

# **Float values: interesting moments**


Float - тип данных дробных чисел, чисел с плавающей точкой, как их ещё называют\
Они могут записываться в различных вариантах:

```python
# float
float_var_1 = -14.6
float_var_2 = float(3) # 3.0
float_var_3 = 5. # 5.0
float_var_4 = .7 # 0.7

print(float_var_1, float_var_2, float_var_3, float_var_4)
print(type(float_var_1))
print(type(float_var_2))
print(type(float_var_3))
print(type(float_var_4))
```

При этом результат будет один и тот же везде. Так же, что следует знать - мы можем\
округлять наши дробные числа. Если дробная часть больше `5` - округление идёт в\
большую сторону. Если дробная часть менее `5` - округление в меньшую сторону.\
В моментах же, когда мы получаем "спорную" дробь (когда у нас ровно 5) как нам быть?

В **Python**, как и во многих других языках программирования, округление "спорных" дробных\
значений, то есть значений, которые находятся ровно посередине между двумя возможными\
округлёнными значениями, происходит с использованием метода, который называется\
**"Banker's rounding"** или округление к ближайшему чётному числу.

При таком методе округления, если дробная часть числа точно равна `0.5`, то число\
округляется к **ближайшему чётному числу**. Например, `2.5` округлится к `2`, а `3.5` округлится\
к `4`. Этот метод используется потому, что он **уменьшает суммарную ошибку при округлении**\
большого количества чисел, делая результаты более нейтральными по сравнению с округлением\
всегда вверх или всегда вниз. Для этих округлений мы обычно используем функцию `round()`

Так же стоит учитывать, что **Python** не особо может в сложение дробей. Всегда есть погрешность.\
Погрешность сложения дробных чисел в **Python** (и в компьютерной арифметике в целом) происходит\
из-за того, что десятичные дроби часто **не могут быть точно представлены в двоичной системе**\
счисления, которая используется компьютерами для хранения чисел. Например, число `0.1`\
(одна десятая) имеет бесконечное представление в двоичной системе, похоже на то, как `1/3`\
имеет бесконечное представление в десятичной системе (`0.333...`). В результате, при выполнении\
арифметических операций с такими числами, возникают небольшие погрешности.

Для демонстрации рассмотрим сложение `0.3 + 0.3 + 0.3` в **Python** и посмотрим на результат.\
Ожидаемым результатом является 0.9, но из-за описанной выше погрешности, результат может\
отличаться. Давайте проверим это на практике.

```python
.3 + .3 + .3
```

Результат сложения `0.3 + 0.3 + 0.3` в **Python** равен `0.8999999999999999`, а не точно `0.9`, как\
можно было ожидать. Это иллюстрирует погрешность, возникающую из-за представления десятичных\
дробей в двоичной форме в компьютерной арифметике. Такие погрешности являются обычным делом\
при работе с плавающей точкой и могут накапливаться в более сложных вычислениях.

Для управления такими погрешностями и выполнения вычислений с требуемой точностью в **Python**\
можно использовать модуль `decimal`, который позволяет выполнять арифметические операции с\
произвольной точностью и контролировать погрешности
