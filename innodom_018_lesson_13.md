# **OOP**

**ООП(Объёктно-Ориентированное Программирование)** - ещё одна концепция\
в разработке, где решение проблемы происходит через создание класса\
и вызовов объекта этого класса. Объект всегда имеет свои\
атрибуты и свои методы.


**Когда может применяться ООП:**


1) когда в решении можно выделить сущность класса;
2) когда сложную логику в функциональности можно описать легко в ООП;
3) в ООП существуют шаблоны, которыми можно описать сложную логику,\
благодаря чему не нужно ничего придумывать;                                                                                     
4) повторное использование кода становится проще;                                                                                 
5) классы удобнее читать и использовать другим разработчикам;                                                                                    
6) для того, чтобы изменить поведение во всех объектах, достаточно изменить\
только класс, что позволяет быстро и надежно исправлять ошибки\
и поддерживать код.


# **OOP VS FUNCTIONS:**

---

**Различия ООП и функций**

|               | работа с классами                                                   | работа с функциями                                          |
|---------------|---------------------------------------------------------------------|-------------------------------------------------------------|
| определение   | Классы позволяют создавать объекты и описывать их свойства и методы | функции выполняют набор инструкций и возвращают значение    |
| состояние     | Объекты класса могут содержать состояние(переменные)                | Функции могут использовать аргументы и локальные переменные |
| использование | Методы класса вызываются на объектах этого класса                   | Функции вызываются с передачей аргументов                   |
| наследование  | Классы могут наследовать свойства и методы других классов           | Функции не могут наследовать свойства и методы              |

---

**Плюсы и минусы работы с классами**

| плюсы                                      | минусы                                              |
|--------------------------------------------|-----------------------------------------------------|
| Модульность и повторное использование кода | Большая сложность и уровень абстракции              |
| Инкапсуляция данных и поведения            | Увеличение объёма кода                              |
| Наследование и полиморфизм                 | Доп затраты на создание и поддержку класса          |
| Организация кода в логические блоки        | Возможность возникновения ошибок из-за наследования |

---

**Где применяется**

| Область применения                                                                                                 |
|--------------------------------------------------------------------------------------------------------------------|
| Разработка больших и сложных программных систем, где необходимо организовать код в модули и логические блоки       |
| Создание объектно-ориентированных библиотек и фреймворков для повторного использования кода                        |
| Моделирование реальных объектов и систем, схожих с реальными объектами (например, моделирование бизнесс-процессов) |
| Создание пользовательских интерфейсов с использованием графических библиотек, таких как PyQt, или Tkinter          |
| Разработка игр и анимаций, где объекты и их поведение являются ключевыми элементами                                |

---

# **Classes && objects:**

В **Python** почти всё, что вы используете является объектом какого-то\
класса (даже типы данных в **Python** реализованы на **ООП**).


```python
a = 5

print(type(a))
print(type("asd"))
print(type([1, 2]))
```

**Классы** – это функции (**методы**) и переменные (**атрибуты**), которые описывают\
определённую, независимую, понятную сущность (**объект**). Иными словами\
класс – это шаблон, которому подчиняется объект.


**Из чего состоит класс?**

* **Инициализатор**
* **Статические** и **динамические** переменные
* **Методы**


```python
class MyTestClass:
    some_int = 7
    my_list = []
    is_false = True

    def __init__(self):
        print(self.some_int)

    def f(self):
        pass

my_var = MyTestClass() # cube 1
my_var2 = MyTestClass() # cube 2
```

**Объект (экземпляр класса)** – это сущность, предмет или явление (**процесс**),\
имеющий чётко выраженные границы, индивидуальность и поведение.\
Создаётся на основе класса и выполняет инструкции, описанные в классе.

**Объекты класса можно создавать в неограниченном количестве.**

**Инициализатор** - место, где инициализируются динамические атрибуты класса

**Методы** - функции, только они находятся в классе и используются для объектов

**Основное отличие функций от методов в том, что методы в классах - динамические.**


`self` – ключевое слово, которое является **ссылкой на объект** и используется\
для вызова методов и атрибутов определённого объекта в классе. Такая\
ссылка передаётся вместе со всеми аргументами, т.к. понимает, к\
какому объекту вы обращаетесь.

```python
class MyTestClass:
    my_int = 10
    hello = "Hello from Class!!!"

    def __init__(self):
        print(self.hello)

    def func(self):
        return str(self)
```


```python
import random

class Cube:
    min_val = 1
    max_val = 6

    def roll(self):
        return random.randint(self.min_val, self.max_val)

cube = Cube()
cube.roll()
```

```python
class Dog:
  def __init__(self):
    print("woof!")

dog = Dog()
```

```python
class Cat:

  def __init__(self, pet_name):  # initializator
    self.cat_name = pet_name
    self.paws = 4
    self.ears = 2
    self.eyes = 2
    self.tail = True
    self.wool = True
    self.energy = 100
    self.sleep = False


  def say_mew(self):
    print(f"Your pet '{self.cat_name}' say 'Mew!'")


  def play(self, action):
    if self.energy >= 20:
            match action:
                case "play with hand":
                    self.energy -= 10
                    return f"The cat has been playing with your hand and is a little tired. {self.energy = }"
                case "play with a laser pointer":
                    self.energy -= 20
                    return f"The cat has been playing with a laser pointer and is a little tired. {self.energy = }"
                case "night madness":
                    return f"The cat's gone into 'night madness' mode. No energy wasted."
    else:
        return "The cat is tired, he's going to bed."
```

# **Class attributes:**

`Свойства (атрибуты класса)` – это все переменные в классе, которые\
могут использовать объекты
                                                  
`Статические свойства` – объявляются в классе и на протяжении всего\
класса являются одинаковым значением

`Динамические свойства` – задают начальное состояние определённому\
объекту и меняются у каждого объекта при выполнении\
какого-либо действия с ним

Все динамические свойства инициализируется в методе `__init__` класса\
и являются начальным состоянием объекта.

---

**Методы** - поведение нашего объекта (то, как и что он может делать)

**Атрибуты** - состояние нашего объекта (то, какие изначально\
параметры у нашего объекта)

# **Class methods classification**

**Методы в ООП можно поделить на следующие фракции:**

* **Магические методы**
* **Динамические методы**
* **Статические методы**
* **Классовые методы**
* **Абстрактные методы**

```python
class Demo:
    counter = 0

    def __init__(self, name) -> None:
        self.name = name

    def dynamic_method(self):
        return f"Hello from dynamyc method! {self.name} ||| {self}"
```

# **Магические методы:**

**Магические методы** - также известные как специальные методы в языке\
**Python** представляют собой специальные функции, которые позволяют\
определить поведение объектов класса при выполнении определенных\
операций. Они начинаются и заканчиваются двойным подчеркиванием:\
(`__init__`, `__str__`, `__len__`...)


* `__init__(self)`: используется для инициализации объекта класса\
и установки его атрибутов(если есть)

```python
class MyClass:
    def __init__(self, value):
        self.value = value

obj = MyClass(42)
```

* `__str__(self)`: возвращает строковое представление объекта\
класса, которое будет использовано при вызове функции str()

```python
class MyClass:
    def __str__(self):
        return "MyClass object"

obj = MyClass()
print(obj)  # Вывод: MyClass object
```

* `__repr__(self)`: Предназначен для создания официального строкового представления\
объекта, которое можно использовать для воссоздания того же объекта\
По идеалу, `__repr__` должен возвращать строку, которую можно использовать\
в Python для получения объекта с такими же данными.


```python
class MyClass:
    def __repr__(self):
        return "MyClass()"

obj = MyClass()
repr(obj)  # Вывод: 'MyClass()'
```

* `__len__(self):` Этот метод позволяет определить длину объекта, когда\
он передается в функцию `len()`. Например, он может быть использован\
для определения количества элементов в пользовательском контейнере\

```python
class MyList:
    def __init__(self, items):
        self.items = items

    def __len__(self):
        return len(self.items)

my_list = MyList([1, 2, 3])
print(len(my_list))
```

* `__getitem__(self, key):` Этот метод позволяет классам создавать\
объекты, которые можно индексировать, как список или словарь.\
Он вызывается при доступе к элементу по индексу,\
например, `obj[key]`.

```python
class MyList:
    def __init__(self, items):
        self.items = items

    def __getitem__(self, index):
        return self.items[index]

my_list = MyList([1, 2, 3])
print(my_list[1])
```

* `__setitem__(self, key, value):` Этот метод используется для установки\
значения элемента, когда объект индексируется, например,\
`obj[key] = value`.

```python
class MyList:
    def __init__(self, items):
        self.items = items

    def __setitem__(self, index, value):
        self.items[index] = value

my_list = MyList([1, 2, 3])
my_list[1] = 42
print(my_list.items)
```

* `__delitem__(self, key):` Этот метод вызывается при удалении элемента\
из объекта, который поддерживает индексирование, например, `del obj[key]`.

```python
class MyList:
    def __init__(self, items):
        self.items = items

    def __delitem__(self, index):
        del self.items[index]

my_list = MyList([1, 2, 3])
del my_list[1]
print(my_list.items)
```

* `__eq__(self, other):` Этот метод используется для определения,\
равны ли два объекта. Он вызывается при использовании оператора `==`.

```python
class Point:
    def __init__(self, x):
        self.x = x

    def __eq__(self, other):
        return self.x == other.x

point1 = Point(1)
point2 = Point(1)
point3 = Point(3)

print(point1 == point2)
print(point1 == point3)
```

* `__lt__(self, other):` Этот метод используется для определения,\
меньше ли объект, чем другой объект. Он вызывается при использовании оператора `<`.

```python
class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __lt__(self, other):
        return self.age < other.age

student1 = Student("Alice", 20)
student2 = Student("Bob", 22)

print(student1 < student2)
```

* `__gt__(self, other):` Этот метод используется для определения, больше\
ли объект, чем другой объект. Он вызывается при использовании оператора `>`.

```python
class Book:
    def __init__(self, title, author):
        self.title = title
        self.author = author

    def __gt__(self, other):
        return self.title > other.title

book1 = Book("Python Basics", "John Smith")
book2 = Book("Advanced Python", "Alice Johnson")

print(book1 > book2)
```

* `__add__(self, other):` Этот метод используется для определения поведения\
объекта при использовании оператора +. Например, он может быть\
использован для сложения объектов.

```python
class ComplexNumber:
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag

    def __add__(self, other):
        real_sum = self.real + other.real
        imag_sum = self.imag + other.imag
        return ComplexNumber(real_sum, imag_sum)

num1 = ComplexNumber(1, 2)
num2 = ComplexNumber(3, 4)
result = num1 + num2

print(result.real, result.imag)
```

* `__sub__(self, other):` Этот метод используется для определения поведения\
объекта при использовании оператора -. Например, он может быть\
использован для вычитания объектов.

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __sub__(self, other):
        new_x = self.x - other.x
        new_y = self.y - other.y
        return Vector(new_x, new_y)

vector1 = Vector(3, 4)
vector2 = Vector(1, 2)
result = vector1 - vector2

print(result.x, result.y)
```

# **Staticmethod**

Наши с вами класс и его будущие инстансы (объекты по этому классу)\
немного отличаются по логике выполнения, и имеют при реализации\
свою самостоятельную среду окружения, стоит об этом помнить.

```python
class StaticTest:
    x = 1

test_1 = StaticTest()

print(f"Via class instance - {test_1.x}")
print(f"Via class - {StaticTest.x}")
```

При создании объекта по классу мы получим отдельную сущность, созданную по\
определённому шаблону. В этом объекте будет своя переменная `x`, которая не\
будет зависеть от нашего `x` в самом классе.

Так же если мы теперь обновим этот атрибут на уровне класса - мы изменим\
именно этот атрибут на уровне самого класса.

```python
StaticTest.x = 3
print(f"Via class instance - {test_1.x}")
print(f"Via class - {StaticTest.x}")
```

Если в дальнейшем по этому классу будем создавать другие инстансы - они переменят\
обновлённое значение `x` для себя.

```python
new_test = StaticTest()
new_test.x
```

Таким образом мы убедились, что атрибуты класса и атрибуты объекта класса\
совершенно различны.


**Что такое статические методы?**

**Статические методы** - это методы, которые привязаны к классу, а не к конкретному\
экземпляру этого класса. Они являются частью класса, а не его объекта, и\
могут вызываться непосредственно из самого класса, без создания экземпляра.

**Статические методы** обычно используются для выполнения операций, не зависящих\
от конкретных атрибутов экземпляров класса.


**Определение статических методов**

**Статический метод** определяется внутри класса с использованием ключевого\
слова `@staticmethod` перед определением метода. Он НЕ принимает обязательного\
параметра `self`, как это делают обычные методы класса. Вместо `self`\
статический метод может принимать другие параметры, необходимые для\
выполнения операции.

В отличие от динамических методов классов, **статические методы не могут**\
**взаимодействовать с атрибутами экземпляра класса**, так как они не имеют\
доступа к `self`. Они могут взаимодействовать только с атрибутами класса,\
которые общие для всех экземпляров.

**Синтаксис статических методов**

```python
class MyClass:
    some_int = 15

    def __init__(self, val1, val2):
        self.val1 = val1
        self.val2 = val2

    @staticmethod
    def sqr_norm(a, b):
        return a*a + b*b
```

Статические методы по факту являются обычными функциями, которые "вшиты"\
в контекст определённого класса.
Они работают независимо от нашего класса, или объекта класса и могут быть\
использованы внутри наших динамических методов \ методов класса.\

Так же такие методы могут вызываться как через сам класс, так и через его\
экземпляр.

```python
my_class = MyClass(5, 5)
my_class.sqr_norm(5, 5)

MyClass.sqr_norm(10, 20)
```

**Где применяются статические методы?**

Использование статических методов для общих операций, не зависящих\
от экземпляра класса
**Статические методы** полезны в ситуациях, когда вы хотите выполнить операции,\
которые не зависят от конкретных атрибутов экземпляров класса, но связаны\
с классом в целом. Например, статические методы могут использоваться для\
**математических вычислений**, **обработки данных** или **вспомогательных функций**.

**Преимущества и недостатки статических методов**

**Преимущества**
1) `Улучшение читаемости кода:`
**Статические методы** могут быть вызваны непосредственно из класса, что делает\
код более читаемым и понятным, поскольку они показывают, что метод не\
зависит от конкретных экземпляров.

2) `Возможность вызова метода без создания объекта:`
**Статические методы** позволяют вызывать операции класса **без необходимости**\
создавать экземпляр класса.

**Недостатки**
1) `Ограниченный доступ к атрибутам экземпляра:`
Статические методы не имеют доступа к атрибутам экземпляра класса, что\
может быть ограничением в некоторых случаях.

2) `Они не могут быть переопределены в подклассах:`\
Статические методы не могут быть переопределены в подклассах, что\
может ограничивать их гибкость.


# **Classmethod**

**Что такое методы класса?**

**Методы класса** - это функции, определенные внутри класса, которые\
имеют доступ к атрибутам и методам самого класса, а не к конкретным\
экземплярам этого класса. Эти методы могут быть вызваны на уровне класса,\
а не только на уровне экземпляра, и они обычно выполняют операции,\
связанные с классом в целом, а не с конкретными объектами.


**Определение методов класса**
**Методы класса** определяются внутри класса и обозначаются декоратором `@classmethod`.\
Они принимают первым параметром ссылку на класс (часто обозначают его как `cls`),\
что позволяет им работать с атрибутами класса и вызывать другие методы класса.

В отличие от динамических методов классов (**методов экземпляра**), методы класса\
**не требуют создания экземпляра класса** для вызова. Они могут вызываться напрямую\
на самом классе.


```python
class SuperClass:
    some_static_argument = "Hello from Class"

    @classmethod
    def get_class_argument(cls):
        return cls.some_static_argument

a = SuperClass()

a.get_class_argument()
a.some_static_argument
SuperClass.get_class_argument()
SuperClass.some_static_argument
```

**Где применяются методы класса?**

Использование методов класса для операций, связанных с классом в целом,\
но не зависящих от конкретного экземпляра

Методы класса часто используются для выполнения операций, которые связаны с\
классом в целом, а не с конкретными объектами класса. Они могут выполнять\
операции на атрибутах класса и обрабатывать данные, которые общие\
для всех экземпляров класса.


**Преимущества и недостатки методов класса**


**Преимущества**

1) `Возможность доступа к атрибутам класса:`
Методы класса имеют доступ к атрибутам класса и могут изменять его состояние,\
делая их мощным инструментом для управления данными, общими для\
всех экземпляров.

2) `Возможность вызова метода на уровне класса:`
Методы класса могут быть вызваны на самом классе без необходимости создания\
экземпляра, что упрощает доступ к функциональности класса.


**Недостатки**

1) `Более сложный синтаксис:` Синтаксис методов класса сложнее, чем у\
статических методов, что может потребовать больше кода для их определения


Используя методы класса, вы можете обеспечить логическую организацию методов,\
которые имеют отношение к классу, но не требуют доступа к конкретным\
экземплярам. Это может повысить читаемость кода и упростить его\
обслуживание. Однако это не предоставляет дополнительных рамок или контекста\
для метода, так как он все равно имеет доступ к глобальным\
атрибутам и методам класса.


**Так же, какое есть преимущество в работе с методами класса:**

Дело в том, что наши классы позволяют в себе хранить только один метод `__init__()`\
То есть для одного класса только один инициализатор.

**В чём может быть проблема?**

Иногда наши классы могут быть определены(инициализированы) по разному.\
Может быть `n` способов вполне себе валидных способов создания объекта\
класса. И для всех этих возможных способов **ВСЕГО ОДИН** инициализатор\
может не подойти - потому что это будет один инициализатор с кучей параметров,\
большая часть из которых будет установлена по умолчанию.

Такие инициализаторы становятся перегруженными, непонятными, их становится крайне\
трудно читать и понимать.

Помимо этого у нашего инициализатора нет имени. Когда мы создаём объект по классу\
мы просто прописываем название класса и просто передаём параметры в\
скобках. Иногда такого синтаксиса недостаточно, чтобы писать "самодокументированный"\
код (код выразительный, который понятен просто по названию метода, в котором он\
содержится, выражает намерения.)

В таких случаях мы можем прибегнуть к нашим методам класса, которые позволят нам\
обыграть это дело.

Плюс тут в том, что у методов класса есть имя, и оно может быть вполне описательным\
Благодаря этому, создавая новый объект класса, используя такой метод, мы\
можем писать более красивый, понятный код, ведь когда мы вызываем такой метод\
нам сразу понятен смысл создания такого объекта класса.

```python
class Date:
    def __init__(self, day, month, year):
        self.day = day
        self.month = month
        self.year = year

    def display(self):
        return f"{self.day}-{self.month}-{self.year}"
```

Допустим мы хотим дать возможность альтернативного использования класса, где\
пользователь указывает своё день рождения конкретно в 2000-ом году.

```python
class Date:
    def __init__(self, day, month, year):
        self.day = day
        self.month = month
        self.year = year

    def display(self):
        return f"{self.day}-{self.month}-{self.year}"

    @classmethod
    def millenium(cls, day, month):
        return cls(day, month, 2000)
```

**Tasks**

Создать класс `Person`, который принимает имя и фамилию в качестве аргументов\
при конструировании.

**Класс должен поддерживать атрибуты:**\

* `first_name`, возвращающий имя
* `last_name`, возвращалию

Класс должен приводить переданные имя и фамилию в форму при которой имя\
и фамилия начинаются с заглавной буквы, а все остальные буквы в нижнем регистре\
(поскольку вызывающий код может передавать такие строки как "JOHN",\
'jOHN', 'sMiTh' и т.д.)

Так же учесть, что пользователь может передать только имя.

Так же наши **classmethods**  так же позволят нам создать такую конструкцию, как\
**СИНГЛТОН**.

**Singleton** - это шаблон проектирования, который гарантирует, что класс имеет\
только один экземпляр, и предоставляет точку доступа к этому экземпляру.\

```python
class Singleton:
    __instance = None

    @classmethod
    def get_instance(cls):
        if cls.__instance is None:
            cls.__instance = cls()
        return cls.__instance


singleton1 = Singleton.get_instance()
singleton2 = Singleton.get_instance()

print(singleton1 == singleton2)
```

**Singleton** можно использовать при создании подключения к базе данных. Каб не было\
много разных объектов подключения к базе данных.


Создание **Singleton** для подключения к базе данных - это распространенная практика,\
которая позволяет уменьшить накладные расходы на создание и разрыв подключений.\
Особенно это актуально для баз данных, которые поддерживают ограниченное\
количество соединений.

```python
import sqlite3

class DatabaseConnection:
    __instance = None

    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()

    @classmethod
    def get_instance(cls, db_name=':memory:'):
        if cls.__instance is None:
            cls.__instance = cls(db_name)
        return cls.__instance

    def close(self):
        self.connection.close()


db_conn = DatabaseConnection.get_instance()
db_conn_2 = DatabaseConnection.get_instance()

print(db_conn is db_conn_2)
```

---

# **Home Tasks**

1) Переписать задачи работы с файлами(json\csv) с наших домашек, на классы.\

2) Реализовать небольшую систему входа:\
* вместо базы данных использовать csv файл
* пользователь может создать аккаунт (name, email, password, repeat_password)
* Реализовать создание аккаунта. проверить наличие такого пользователя\
по email. Если есть - вывести сообщение, что такой пользователь\
уже есть, аккаунт создать нельзя. Если нет - создать аккаунт,\
данные записать в csv файл.
* Реализация входа в систему. Проверять наличие пользователя по email.\
Проверка пароля. Учесть все возможные расхождения, ошибки.

Все данные берутся и записываются из csv файла.\
Пароль должен валидироваться. Можете написать его реализацию через staticmethod
